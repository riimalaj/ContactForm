/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/Huolto/lisaaHuolto"],{

/***/ "./node_modules/.prisma/client/index-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/.prisma/client/index-browser.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst {\n  Decimal\n} = __webpack_require__(/*! @prisma/client/runtime/index-browser */ \"./node_modules/@prisma/client/runtime/index-browser.js\")\n\n\nconst Prisma = {}\n\nexports.Prisma = Prisma\n\n/**\n * Prisma Client JS version: 3.15.1\n * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e\n */\nPrisma.prismaVersion = {\n  client: \"3.15.1\",\n  engine: \"461d6a05159055555eb7dfb337c9fb271cbd4d7e\"\n}\n\nPrisma.PrismaClientKnownRequestError = () => {\n  throw new Error(`PrismaClientKnownRequestError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)};\nPrisma.PrismaClientUnknownRequestError = () => {\n  throw new Error(`PrismaClientUnknownRequestError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientRustPanicError = () => {\n  throw new Error(`PrismaClientRustPanicError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientInitializationError = () => {\n  throw new Error(`PrismaClientInitializationError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientValidationError = () => {\n  throw new Error(`PrismaClientValidationError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.Decimal = Decimal\n\n/**\n * Re-export of sql-template-tag\n */\nPrisma.sql = () => {\n  throw new Error(`sqltag is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.empty = () => {\n  throw new Error(`empty is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.join = () => {\n  throw new Error(`join is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.raw = () => {\n  throw new Error(`raw is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.validator = () => (val) => val\n\n/**\n * Shorthand utilities for JSON filtering\n */\nPrisma.DbNull = 'DbNull'\nPrisma.JsonNull = 'JsonNull'\nPrisma.AnyNull = 'AnyNull'\n\n/**\n * Enums\n */\n// Based on\n// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nfunction makeEnum(x) { return x; }\n\nexports.Prisma.HuoltoScalarFieldEnum = makeEnum({\n  id: 'id',\n  createdAt: 'createdAt',\n  kohde: 'kohde',\n  huolto: 'huolto',\n  km: 'km',\n  info: 'info'\n});\n\nexports.Prisma.ContactScalarFieldEnum = makeEnum({\n  id: 'id',\n  fName: 'fName',\n  lName: 'lName',\n  tel: 'tel',\n  email: 'email',\n  other: 'other'\n});\n\nexports.Prisma.SortOrder = makeEnum({\n  asc: 'asc',\n  desc: 'desc'\n});\n\nexports.Prisma.QueryMode = makeEnum({\n  default: 'default',\n  insensitive: 'insensitive'\n});\n\n\nexports.Prisma.ModelName = makeEnum({\n  Huolto: 'Huolto',\n  Contact: 'Contact'\n});\n\n/**\n * Create the Client\n */\nclass PrismaClient {\n  constructor() {\n    throw new Error(\n      `PrismaClient is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n    )\n  }\n}\nexports.PrismaClient = PrismaClient\n\nObject.assign(exports, Prisma)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsb0dBQXNDOzs7QUFHbEQ7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7O0FBRUQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wcmlzbWEvY2xpZW50L2luZGV4LWJyb3dzZXIuanM/ZWJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3Qge1xuICBEZWNpbWFsXG59ID0gcmVxdWlyZSgnQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleC1icm93c2VyJylcblxuXG5jb25zdCBQcmlzbWEgPSB7fVxuXG5leHBvcnRzLlByaXNtYSA9IFByaXNtYVxuXG4vKipcbiAqIFByaXNtYSBDbGllbnQgSlMgdmVyc2lvbjogMy4xNS4xXG4gKiBRdWVyeSBFbmdpbmUgdmVyc2lvbjogNDYxZDZhMDUxNTkwNTU1NTVlYjdkZmIzMzdjOWZiMjcxY2JkNGQ3ZVxuICovXG5QcmlzbWEucHJpc21hVmVyc2lvbiA9IHtcbiAgY2xpZW50OiBcIjMuMTUuMVwiLFxuICBlbmdpbmU6IFwiNDYxZDZhMDUxNTkwNTU1NTVlYjdkZmIzMzdjOWZiMjcxY2JkNGQ3ZVwiXG59XG5cblByaXNtYS5QcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciBpcyB1bmFibGUgdG8gYmUgcnVuIGluIHRoZSBicm93c2VyLlxuSW4gY2FzZSB0aGlzIGVycm9yIGlzIHVuZXhwZWN0ZWQgZm9yIHlvdSwgcGxlYXNlIHJlcG9ydCBpdCBpbiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNgLFxuKX07XG5QcmlzbWEuUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvciBpcyB1bmFibGUgdG8gYmUgcnVuIGluIHRoZSBicm93c2VyLlxuSW4gY2FzZSB0aGlzIGVycm9yIGlzIHVuZXhwZWN0ZWQgZm9yIHlvdSwgcGxlYXNlIHJlcG9ydCBpdCBpbiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNgLFxuKX1cblByaXNtYS5QcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLkRlY2ltYWwgPSBEZWNpbWFsXG5cbi8qKlxuICogUmUtZXhwb3J0IG9mIHNxbC10ZW1wbGF0ZS10YWdcbiAqL1xuUHJpc21hLnNxbCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBzcWx0YWcgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuZW1wdHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgZW1wdHkgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuam9pbiA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBqb2luIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLnJhdyA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGByYXcgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEudmFsaWRhdG9yID0gKCkgPT4gKHZhbCkgPT4gdmFsXG5cbi8qKlxuICogU2hvcnRoYW5kIHV0aWxpdGllcyBmb3IgSlNPTiBmaWx0ZXJpbmdcbiAqL1xuUHJpc21hLkRiTnVsbCA9ICdEYk51bGwnXG5QcmlzbWEuSnNvbk51bGwgPSAnSnNvbk51bGwnXG5QcmlzbWEuQW55TnVsbCA9ICdBbnlOdWxsJ1xuXG4vKipcbiAqIEVudW1zXG4gKi9cbi8vIEJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxOTIjaXNzdWVjb21tZW50LTI2MTcyMDI3NVxuZnVuY3Rpb24gbWFrZUVudW0oeCkgeyByZXR1cm4geDsgfVxuXG5leHBvcnRzLlByaXNtYS5IdW9sdG9TY2FsYXJGaWVsZEVudW0gPSBtYWtlRW51bSh7XG4gIGlkOiAnaWQnLFxuICBjcmVhdGVkQXQ6ICdjcmVhdGVkQXQnLFxuICBrb2hkZTogJ2tvaGRlJyxcbiAgaHVvbHRvOiAnaHVvbHRvJyxcbiAga206ICdrbScsXG4gIGluZm86ICdpbmZvJ1xufSk7XG5cbmV4cG9ydHMuUHJpc21hLkNvbnRhY3RTY2FsYXJGaWVsZEVudW0gPSBtYWtlRW51bSh7XG4gIGlkOiAnaWQnLFxuICBmTmFtZTogJ2ZOYW1lJyxcbiAgbE5hbWU6ICdsTmFtZScsXG4gIHRlbDogJ3RlbCcsXG4gIGVtYWlsOiAnZW1haWwnLFxuICBvdGhlcjogJ290aGVyJ1xufSk7XG5cbmV4cG9ydHMuUHJpc21hLlNvcnRPcmRlciA9IG1ha2VFbnVtKHtcbiAgYXNjOiAnYXNjJyxcbiAgZGVzYzogJ2Rlc2MnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuUXVlcnlNb2RlID0gbWFrZUVudW0oe1xuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGluc2Vuc2l0aXZlOiAnaW5zZW5zaXRpdmUnXG59KTtcblxuXG5leHBvcnRzLlByaXNtYS5Nb2RlbE5hbWUgPSBtYWtlRW51bSh7XG4gIEh1b2x0bzogJ0h1b2x0bycsXG4gIENvbnRhY3Q6ICdDb250YWN0J1xufSk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBDbGllbnRcbiAqL1xuY2xhc3MgUHJpc21hQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFByaXNtYUNsaWVudCBpcyB1bmFibGUgdG8gYmUgcnVuIGluIHRoZSBicm93c2VyLlxuSW4gY2FzZSB0aGlzIGVycm9yIGlzIHVuZXhwZWN0ZWQgZm9yIHlvdSwgcGxlYXNlIHJlcG9ydCBpdCBpbiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNgLFxuICAgIClcbiAgfVxufVxuZXhwb3J0cy5QcmlzbWFDbGllbnQgPSBQcmlzbWFDbGllbnRcblxuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBQcmlzbWEpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.prisma/client/index-browser.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/runtime/index-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prisma/client/runtime/index-browser.js ***!
  \**************************************************************/
/***/ (function(module) {

eval("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// src/runtime/index-browser.ts\nvar index_browser_exports = {};\n__export(index_browser_exports, {\n  Decimal: () => decimal_default\n});\nmodule.exports = __toCommonJS(index_browser_exports);\n\n// ../../node_modules/.pnpm/decimal.js@10.3.1/node_modules/decimal.js/decimal.mjs\nvar EXP_LIMIT = 9e15;\nvar MAX_DIGITS = 1e9;\nvar NUMERALS = \"0123456789abcdef\";\nvar LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\";\nvar PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\";\nvar DEFAULTS = {\n  precision: 20,\n  rounding: 4,\n  modulo: 1,\n  toExpNeg: -7,\n  toExpPos: 21,\n  minE: -EXP_LIMIT,\n  maxE: EXP_LIMIT,\n  crypto: false\n};\nvar inexact;\nvar quadrant;\nvar external = true;\nvar decimalError = \"[DecimalError] \";\nvar invalidArgument = decimalError + \"Invalid argument: \";\nvar precisionLimitExceeded = decimalError + \"Precision limit exceeded\";\nvar cryptoUnavailable = decimalError + \"crypto unavailable\";\nvar tag = \"[object Decimal]\";\nvar mathfloor = Math.floor;\nvar mathpow = Math.pow;\nvar isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i;\nvar isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i;\nvar isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i;\nvar isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\nvar BASE = 1e7;\nvar LOG_BASE = 7;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar LN10_PRECISION = LN10.length - 1;\nvar PI_PRECISION = PI.length - 1;\nvar P = { toStringTag: tag };\nP.absoluteValue = P.abs = function() {\n  var x = new this.constructor(this);\n  if (x.s < 0)\n    x.s = 1;\n  return finalise(x);\n};\nP.ceil = function() {\n  return finalise(new this.constructor(this), this.e + 1, 2);\n};\nP.clampedTo = P.clamp = function(min2, max2) {\n  var k, x = this, Ctor = x.constructor;\n  min2 = new Ctor(min2);\n  max2 = new Ctor(max2);\n  if (!min2.s || !max2.s)\n    return new Ctor(NaN);\n  if (min2.gt(max2))\n    throw Error(invalidArgument + max2);\n  k = x.cmp(min2);\n  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);\n};\nP.comparedTo = P.cmp = function(y) {\n  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n  if (!xd || !yd) {\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n  }\n  if (!xd[0] || !yd[0])\n    return xd[0] ? xs : yd[0] ? -ys : 0;\n  if (xs !== ys)\n    return xs;\n  if (x.e !== y.e)\n    return x.e > y.e ^ xs < 0 ? 1 : -1;\n  xdL = xd.length;\n  ydL = yd.length;\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n    if (xd[i] !== yd[i])\n      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n  }\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\nP.cosine = P.cos = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.d)\n    return new Ctor(NaN);\n  if (!x.d[0])\n    return new Ctor(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\nP.cubeRoot = P.cbrt = function() {\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  external = false;\n  s = x.s * mathpow(x.s * x, 1 / 3);\n  if (!s || Math.abs(s) == 1 / 0) {\n    n = digitsToString(x.d);\n    e = x.e;\n    if (s = (e - n.length + 1) % 3)\n      n += s == 1 || s == -2 ? \"0\" : \"00\";\n    s = mathpow(n, 1 / 3);\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n    r.s = x.s;\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    t3 = t.times(t).times(t);\n    t3plusx = t3.plus(x);\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.decimalPlaces = P.dp = function() {\n  var w, d = this.d, n = NaN;\n  if (d) {\n    w = d.length - 1;\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n    w = d[w];\n    if (w)\n      for (; w % 10 == 0; w /= 10)\n        n--;\n    if (n < 0)\n      n = 0;\n  }\n  return n;\n};\nP.dividedBy = P.div = function(y) {\n  return divide(this, new this.constructor(y));\n};\nP.dividedToIntegerBy = P.divToInt = function(y) {\n  var x = this, Ctor = x.constructor;\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\nP.equals = P.eq = function(y) {\n  return this.cmp(y) === 0;\n};\nP.floor = function() {\n  return finalise(new this.constructor(this), this.e + 1, 3);\n};\nP.greaterThan = P.gt = function(y) {\n  return this.cmp(y) > 0;\n};\nP.greaterThanOrEqualTo = P.gte = function(y) {\n  var k = this.cmp(y);\n  return k == 1 || k === 0;\n};\nP.hyperbolicCosine = P.cosh = function() {\n  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n  if (!x.isFinite())\n    return new Ctor(x.s ? 1 / 0 : NaN);\n  if (x.isZero())\n    return one;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    n = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    n = \"2.3283064365386962890625e-10\";\n  }\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n  var cosh2_x, i = k, d8 = new Ctor(8);\n  for (; i--; ) {\n    cosh2_x = x.times(x);\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n  }\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.hyperbolicSine = P.sinh = function() {\n  var k, pr, rm, len, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 3) {\n    x = taylorSeries(Ctor, 2, x, x, true);\n  } else {\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x, true);\n    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for (; k--; ) {\n      sinh2_x = x.times(x);\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n    }\n  }\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(x, pr, rm, true);\n};\nP.hyperbolicTangent = P.tanh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(x.s);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 7;\n  Ctor.rounding = 1;\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\nP.inverseCosine = P.acos = function() {\n  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n  if (k !== -1) {\n    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n  }\n  if (x.isZero())\n    return getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.asin();\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return halfPi.minus(x);\n};\nP.inverseHyperbolicCosine = P.acosh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (x.lte(1))\n    return new Ctor(x.eq(1) ? 0 : NaN);\n  if (!x.isFinite())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).minus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicSine = P.asinh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).plus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicTangent = P.atanh = function() {\n  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.e >= 0)\n    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  xsd = x.sd();\n  if (Math.max(xsd, pr) < 2 * -x.e - 1)\n    return finalise(new Ctor(x), pr, rm, true);\n  Ctor.precision = wpr = xsd - x.e;\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n  Ctor.precision = pr + 4;\n  Ctor.rounding = 1;\n  x = x.ln();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(0.5);\n};\nP.inverseSine = P.asin = function() {\n  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n  if (x.isZero())\n    return new Ctor(x);\n  k = x.abs().cmp(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (k !== -1) {\n    if (k === 0) {\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      halfPi.s = x.s;\n      return halfPi;\n    }\n    return new Ctor(NaN);\n  }\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseTangent = P.atan = function() {\n  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n  if (!x.isFinite()) {\n    if (!x.s)\n      return new Ctor(NaN);\n    if (pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\n      r.s = x.s;\n      return r;\n    }\n  } else if (x.isZero()) {\n    return new Ctor(x);\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\n    r.s = x.s;\n    return r;\n  }\n  Ctor.precision = wpr = pr + 10;\n  Ctor.rounding = 1;\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n  for (i = k; i; --i)\n    x = x.div(x.times(x).plus(1).sqrt().plus(1));\n  external = false;\n  j = Math.ceil(wpr / LOG_BASE);\n  n = 1;\n  x2 = x.times(x);\n  r = new Ctor(x);\n  px = x;\n  for (; i !== -1; ) {\n    px = px.times(x2);\n    t = r.minus(px.div(n += 2));\n    px = px.times(x2);\n    r = t.plus(px.div(n += 2));\n    if (r.d[j] !== void 0)\n      for (i = j; r.d[i] === t.d[i] && i--; )\n        ;\n  }\n  if (k)\n    r = r.times(2 << k - 1);\n  external = true;\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.isFinite = function() {\n  return !!this.d;\n};\nP.isInteger = P.isInt = function() {\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\nP.isNaN = function() {\n  return !this.s;\n};\nP.isNegative = P.isNeg = function() {\n  return this.s < 0;\n};\nP.isPositive = P.isPos = function() {\n  return this.s > 0;\n};\nP.isZero = function() {\n  return !!this.d && this.d[0] === 0;\n};\nP.lessThan = P.lt = function(y) {\n  return this.cmp(y) < 0;\n};\nP.lessThanOrEqualTo = P.lte = function(y) {\n  return this.cmp(y) < 1;\n};\nP.logarithm = P.log = function(base) {\n  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n  if (base == null) {\n    base = new Ctor(10);\n    isBase10 = true;\n  } else {\n    base = new Ctor(base);\n    d = base.d;\n    if (base.s < 0 || !d || !d[0] || base.eq(1))\n      return new Ctor(NaN);\n    isBase10 = base.eq(10);\n  }\n  d = arg.d;\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n  }\n  if (isBase10) {\n    if (d.length > 1) {\n      inf = true;\n    } else {\n      for (k = d[0]; k % 10 === 0; )\n        k /= 10;\n      inf = k !== 1;\n    }\n  }\n  external = false;\n  sd = pr + guard;\n  num = naturalLogarithm(arg, sd);\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n  r = divide(num, denominator, sd, 1);\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\n    do {\n      sd += 10;\n      num = naturalLogarithm(arg, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (!inf) {\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n        break;\n      }\n    } while (checkRoundingDigits(r.d, k += 10, rm));\n  }\n  external = true;\n  return finalise(r, pr, rm);\n};\nP.minus = P.sub = function(y) {\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (x.d)\n      y.s = -y.s;\n    else\n      y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.plus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (yd[0])\n      y.s = -y.s;\n    else if (xd[0])\n      y = new Ctor(x);\n    else\n      return new Ctor(rm === 3 ? -0 : 0);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  e = mathfloor(y.e / LOG_BASE);\n  xe = mathfloor(x.e / LOG_BASE);\n  xd = xd.slice();\n  k = xe - e;\n  if (k) {\n    xLTy = k < 0;\n    if (xLTy) {\n      d = xd;\n      k = -k;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = xe;\n      len = xd.length;\n    }\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n    if (k > i) {\n      k = i;\n      d.length = 1;\n    }\n    d.reverse();\n    for (i = k; i--; )\n      d.push(0);\n    d.reverse();\n  } else {\n    i = xd.length;\n    len = yd.length;\n    xLTy = i < len;\n    if (xLTy)\n      len = i;\n    for (i = 0; i < len; i++) {\n      if (xd[i] != yd[i]) {\n        xLTy = xd[i] < yd[i];\n        break;\n      }\n    }\n    k = 0;\n  }\n  if (xLTy) {\n    d = xd;\n    xd = yd;\n    yd = d;\n    y.s = -y.s;\n  }\n  len = xd.length;\n  for (i = yd.length - len; i > 0; --i)\n    xd[len++] = 0;\n  for (i = yd.length; i > k; ) {\n    if (xd[--i] < yd[i]) {\n      for (j = i; j && xd[--j] === 0; )\n        xd[j] = BASE - 1;\n      --xd[j];\n      xd[i] += BASE;\n    }\n    xd[i] -= yd[i];\n  }\n  for (; xd[--len] === 0; )\n    xd.pop();\n  for (; xd[0] === 0; xd.shift())\n    --e;\n  if (!xd[0])\n    return new Ctor(rm === 3 ? -0 : 0);\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.modulo = P.mod = function(y) {\n  var q, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.s || y.d && !y.d[0])\n    return new Ctor(NaN);\n  if (!y.d || x.d && !x.d[0]) {\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n  }\n  external = false;\n  if (Ctor.modulo == 9) {\n    q = divide(x, y.abs(), 0, 3, 1);\n    q.s *= y.s;\n  } else {\n    q = divide(x, y, 0, Ctor.modulo, 1);\n  }\n  q = q.times(y);\n  external = true;\n  return x.minus(q);\n};\nP.naturalExponential = P.exp = function() {\n  return naturalExponential(this);\n};\nP.naturalLogarithm = P.ln = function() {\n  return naturalLogarithm(this);\n};\nP.negated = P.neg = function() {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return finalise(x);\n};\nP.plus = P.add = function(y) {\n  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (!x.d)\n      y = new Ctor(y.d || x.s === y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (!yd[0])\n      y = new Ctor(x);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  k = mathfloor(x.e / LOG_BASE);\n  e = mathfloor(y.e / LOG_BASE);\n  xd = xd.slice();\n  i = k - e;\n  if (i) {\n    if (i < 0) {\n      d = xd;\n      i = -i;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = k;\n      len = xd.length;\n    }\n    k = Math.ceil(pr / LOG_BASE);\n    len = k > len ? k + 1 : len + 1;\n    if (i > len) {\n      i = len;\n      d.length = 1;\n    }\n    d.reverse();\n    for (; i--; )\n      d.push(0);\n    d.reverse();\n  }\n  len = xd.length;\n  i = yd.length;\n  if (len - i < 0) {\n    i = len;\n    d = yd;\n    yd = xd;\n    xd = d;\n  }\n  for (carry = 0; i; ) {\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n    xd[i] %= BASE;\n  }\n  if (carry) {\n    xd.unshift(carry);\n    ++e;\n  }\n  for (len = xd.length; xd[--len] == 0; )\n    xd.pop();\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.precision = P.sd = function(z) {\n  var k, x = this;\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)\n    throw Error(invalidArgument + z);\n  if (x.d) {\n    k = getPrecision(x.d);\n    if (z && x.e + 1 > k)\n      k = x.e + 1;\n  } else {\n    k = NaN;\n  }\n  return k;\n};\nP.round = function() {\n  var x = this, Ctor = x.constructor;\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\nP.sine = P.sin = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\nP.squareRoot = P.sqrt = function() {\n  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n  if (s !== 1 || !d || !d[0]) {\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n  }\n  external = false;\n  s = Math.sqrt(+x);\n  if (s == 0 || s == 1 / 0) {\n    n = digitsToString(d);\n    if ((n.length + e) % 2 == 0)\n      n += \"0\";\n    s = Math.sqrt(n);\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.tangent = P.tan = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 10;\n  Ctor.rounding = 1;\n  x = x.sin();\n  x.s = 1;\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\nP.times = P.mul = function(y) {\n  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n  y.s *= x.s;\n  if (!xd || !xd[0] || !yd || !yd[0]) {\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n  }\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n  xdL = xd.length;\n  ydL = yd.length;\n  if (xdL < ydL) {\n    r = xd;\n    xd = yd;\n    yd = r;\n    rL = xdL;\n    xdL = ydL;\n    ydL = rL;\n  }\n  r = [];\n  rL = xdL + ydL;\n  for (i = rL; i--; )\n    r.push(0);\n  for (i = ydL; --i >= 0; ) {\n    carry = 0;\n    for (k = xdL + i; k > i; ) {\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\n      r[k--] = t % BASE | 0;\n      carry = t / BASE | 0;\n    }\n    r[k] = (r[k] + carry) % BASE | 0;\n  }\n  for (; !r[--rL]; )\n    r.pop();\n  if (carry)\n    ++e;\n  else\n    r.shift();\n  y.d = r;\n  y.e = getBase10Exponent(r, e);\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\nP.toBinary = function(sd, rm) {\n  return toStringBinary(this, 2, sd, rm);\n};\nP.toDecimalPlaces = P.toDP = function(dp, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (dp === void 0)\n    return x;\n  checkInt32(dp, 0, MAX_DIGITS);\n  if (rm === void 0)\n    rm = Ctor.rounding;\n  else\n    checkInt32(rm, 0, 8);\n  return finalise(x, dp + x.e + 1, rm);\n};\nP.toExponential = function(dp, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x, true);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), dp + 1, rm);\n    str = finiteToString(x, true, dp + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFixed = function(dp, rm) {\n  var str, y, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\n    str = finiteToString(y, false, dp + y.e + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFraction = function(maxD) {\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n  if (!xd)\n    return new Ctor(x);\n  n1 = d0 = new Ctor(1);\n  d1 = n0 = new Ctor(0);\n  d = new Ctor(d1);\n  e = d.e = getPrecision(xd) - x.e - 1;\n  k = e % LOG_BASE;\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n  if (maxD == null) {\n    maxD = e > 0 ? d : n1;\n  } else {\n    n = new Ctor(maxD);\n    if (!n.isInt() || n.lt(n1))\n      throw Error(invalidArgument + n);\n    maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n  }\n  external = false;\n  n = new Ctor(digitsToString(xd));\n  pr = Ctor.precision;\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\n  for (; ; ) {\n    q = divide(n, d, 0, 1, 1);\n    d2 = d0.plus(q.times(d1));\n    if (d2.cmp(maxD) == 1)\n      break;\n    d0 = d1;\n    d1 = d2;\n    d2 = n1;\n    n1 = n0.plus(q.times(d2));\n    n0 = d2;\n    d2 = d;\n    d = n.minus(q.times(d2));\n    n = d2;\n  }\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n  n0 = n0.plus(d2.times(n1));\n  d0 = d0.plus(d2.times(d1));\n  n0.s = n1.s = x.s;\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n  Ctor.precision = pr;\n  external = true;\n  return r;\n};\nP.toHexadecimal = P.toHex = function(sd, rm) {\n  return toStringBinary(this, 16, sd, rm);\n};\nP.toNearest = function(y, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (y == null) {\n    if (!x.d)\n      return x;\n    y = new Ctor(1);\n    rm = Ctor.rounding;\n  } else {\n    y = new Ctor(y);\n    if (rm === void 0) {\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(rm, 0, 8);\n    }\n    if (!x.d)\n      return y.s ? x : y;\n    if (!y.d) {\n      if (y.s)\n        y.s = x.s;\n      return y;\n    }\n  }\n  if (y.d[0]) {\n    external = false;\n    x = divide(x, y, 0, rm, 1).times(y);\n    external = true;\n    finalise(x);\n  } else {\n    y.s = x.s;\n    x = y;\n  }\n  return x;\n};\nP.toNumber = function() {\n  return +this;\n};\nP.toOctal = function(sd, rm) {\n  return toStringBinary(this, 8, sd, rm);\n};\nP.toPower = P.pow = function(y) {\n  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n  if (!x.d || !y.d || !x.d[0] || !y.d[0])\n    return new Ctor(mathpow(+x, yn));\n  x = new Ctor(x);\n  if (x.eq(1))\n    return x;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (y.eq(1))\n    return finalise(x, pr, rm);\n  e = mathfloor(y.e / LOG_BASE);\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n    r = intPow(Ctor, x, k, pr);\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n  }\n  s = x.s;\n  if (s < 0) {\n    if (e < y.d.length - 1)\n      return new Ctor(NaN);\n    if ((y.d[e] & 1) == 0)\n      s = 1;\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n      x.s = s;\n      return x;\n    }\n  }\n  k = mathpow(+x, yn);\n  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)\n    return new Ctor(e > 0 ? s / 0 : 0);\n  external = false;\n  Ctor.rounding = x.s = 1;\n  k = Math.min(12, (e + \"\").length);\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n  if (r.d) {\n    r = finalise(r, pr + 5, 1);\n    if (checkRoundingDigits(r.d, pr, rm)) {\n      e = pr + 10;\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n        r = finalise(r, pr + 1, 0);\n      }\n    }\n  }\n  r.s = s;\n  external = true;\n  Ctor.rounding = rm;\n  return finalise(r, pr, rm);\n};\nP.toPrecision = function(sd, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), sd, rm);\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toSignificantDigits = P.toSD = function(sd, rm) {\n  var x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  }\n  return finalise(new Ctor(x), sd, rm);\n};\nP.toString = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.truncated = P.trunc = function() {\n  return finalise(new this.constructor(this), this.e + 1, 1);\n};\nP.valueOf = P.toJSON = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() ? \"-\" + str : str;\n};\nfunction digitsToString(d) {\n  var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n  if (indexOfLastWord > 0) {\n    str += w;\n    for (i = 1; i < indexOfLastWord; i++) {\n      ws = d[i] + \"\";\n      k = LOG_BASE - ws.length;\n      if (k)\n        str += getZeroString(k);\n      str += ws;\n    }\n    w = d[i];\n    ws = w + \"\";\n    k = LOG_BASE - ws.length;\n    if (k)\n      str += getZeroString(k);\n  } else if (w === 0) {\n    return \"0\";\n  }\n  for (; w % 10 === 0; )\n    w /= 10;\n  return str + w;\n}\n__name(digitsToString, \"digitsToString\");\nfunction checkInt32(i, min2, max2) {\n  if (i !== ~~i || i < min2 || i > max2) {\n    throw Error(invalidArgument + i);\n  }\n}\n__name(checkInt32, \"checkInt32\");\nfunction checkRoundingDigits(d, i, rm, repeating) {\n  var di, k, r, rd;\n  for (k = d[0]; k >= 10; k /= 10)\n    --i;\n  if (--i < 0) {\n    i += LOG_BASE;\n    di = 0;\n  } else {\n    di = Math.ceil((i + 1) / LOG_BASE);\n    i %= LOG_BASE;\n  }\n  k = mathpow(10, LOG_BASE - i);\n  rd = d[di] % k | 0;\n  if (repeating == null) {\n    if (i < 3) {\n      if (i == 0)\n        rd = rd / 100 | 0;\n      else if (i == 1)\n        rd = rd / 10 | 0;\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n    } else {\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n    }\n  } else {\n    if (i < 4) {\n      if (i == 0)\n        rd = rd / 1e3 | 0;\n      else if (i == 1)\n        rd = rd / 100 | 0;\n      else if (i == 2)\n        rd = rd / 10 | 0;\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n    } else {\n      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n    }\n  }\n  return r;\n}\n__name(checkRoundingDigits, \"checkRoundingDigits\");\nfunction convertBase(str, baseIn, baseOut) {\n  var j, arr = [0], arrL, i = 0, strL = str.length;\n  for (; i < strL; ) {\n    for (arrL = arr.length; arrL--; )\n      arr[arrL] *= baseIn;\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\n    for (j = 0; j < arr.length; j++) {\n      if (arr[j] > baseOut - 1) {\n        if (arr[j + 1] === void 0)\n          arr[j + 1] = 0;\n        arr[j + 1] += arr[j] / baseOut | 0;\n        arr[j] %= baseOut;\n      }\n    }\n  }\n  return arr.reverse();\n}\n__name(convertBase, \"convertBase\");\nfunction cosine(Ctor, x) {\n  var k, len, y;\n  if (x.isZero())\n    return x;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    y = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    y = \"2.3283064365386962890625e-10\";\n  }\n  Ctor.precision += k;\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n  for (var i = k; i--; ) {\n    var cos2x = x.times(x);\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n  }\n  Ctor.precision -= k;\n  return x;\n}\n__name(cosine, \"cosine\");\nvar divide = function() {\n  function multiplyInteger(x, k, base) {\n    var temp, carry = 0, i = x.length;\n    for (x = x.slice(); i--; ) {\n      temp = x[i] * k + carry;\n      x[i] = temp % base | 0;\n      carry = temp / base | 0;\n    }\n    if (carry)\n      x.unshift(carry);\n    return x;\n  }\n  __name(multiplyInteger, \"multiplyInteger\");\n  function compare(a, b, aL, bL) {\n    var i, r;\n    if (aL != bL) {\n      r = aL > bL ? 1 : -1;\n    } else {\n      for (i = r = 0; i < aL; i++) {\n        if (a[i] != b[i]) {\n          r = a[i] > b[i] ? 1 : -1;\n          break;\n        }\n      }\n    }\n    return r;\n  }\n  __name(compare, \"compare\");\n  function subtract(a, b, aL, base) {\n    var i = 0;\n    for (; aL--; ) {\n      a[aL] -= i;\n      i = a[aL] < b[aL] ? 1 : 0;\n      a[aL] = i * base + a[aL] - b[aL];\n    }\n    for (; !a[0] && a.length > 1; )\n      a.shift();\n  }\n  __name(subtract, \"subtract\");\n  return function(x, y, pr, rm, dp, base) {\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);\n    }\n    if (base) {\n      logBase = 1;\n      e = x.e - y.e;\n    } else {\n      base = BASE;\n      logBase = LOG_BASE;\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n    }\n    yL = yd.length;\n    xL = xd.length;\n    q = new Ctor(sign2);\n    qd = q.d = [];\n    for (i = 0; yd[i] == (xd[i] || 0); i++)\n      ;\n    if (yd[i] > (xd[i] || 0))\n      e--;\n    if (pr == null) {\n      sd = pr = Ctor.precision;\n      rm = Ctor.rounding;\n    } else if (dp) {\n      sd = pr + (x.e - y.e) + 1;\n    } else {\n      sd = pr;\n    }\n    if (sd < 0) {\n      qd.push(1);\n      more = true;\n    } else {\n      sd = sd / logBase + 2 | 0;\n      i = 0;\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++;\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * base + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        }\n        more = k || i < xL;\n      } else {\n        k = base / (yd[0] + 1) | 0;\n        if (k > 1) {\n          yd = multiplyInteger(yd, k, base);\n          xd = multiplyInteger(xd, k, base);\n          yL = yd.length;\n          xL = xd.length;\n        }\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length;\n        for (; remL < yL; )\n          rem[remL++] = 0;\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= base / 2)\n          ++yd0;\n        do {\n          k = 0;\n          cmp = compare(yd, rem, yL, remL);\n          if (cmp < 0) {\n            rem0 = rem[0];\n            if (yL != remL)\n              rem0 = rem0 * base + (rem[1] || 0);\n            k = rem0 / yd0 | 0;\n            if (k > 1) {\n              if (k >= base)\n                k = base - 1;\n              prod = multiplyInteger(yd, k, base);\n              prodL = prod.length;\n              remL = rem.length;\n              cmp = compare(prod, rem, prodL, remL);\n              if (cmp == 1) {\n                k--;\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n              }\n            } else {\n              if (k == 0)\n                cmp = k = 1;\n              prod = yd.slice();\n            }\n            prodL = prod.length;\n            if (prodL < remL)\n              prod.unshift(0);\n            subtract(rem, prod, remL, base);\n            if (cmp == -1) {\n              remL = rem.length;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 1) {\n                k++;\n                subtract(rem, yL < remL ? yz : yd, remL, base);\n              }\n            }\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          }\n          qd[i++] = k;\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n        more = rem[0] !== void 0;\n      }\n      if (!qd[0])\n        qd.shift();\n    }\n    if (logBase == 1) {\n      q.e = e;\n      inexact = more;\n    } else {\n      for (i = 1, k = qd[0]; k >= 10; k /= 10)\n        i++;\n      q.e = i + e * logBase - 1;\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n    }\n    return q;\n  };\n}();\nfunction finalise(x, sd, rm, isTruncated) {\n  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n  out:\n    if (sd != null) {\n      xd = x.d;\n      if (!xd)\n        return x;\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10)\n        digits++;\n      i = sd - digits;\n      if (i < 0) {\n        i += LOG_BASE;\n        j = sd;\n        w = xd[xdi = 0];\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n      } else {\n        xdi = Math.ceil((i + 1) / LOG_BASE);\n        k = xd.length;\n        if (xdi >= k) {\n          if (isTruncated) {\n            for (; k++ <= xdi; )\n              xd.push(0);\n            w = rd = 0;\n            digits = 1;\n            i %= LOG_BASE;\n            j = i - LOG_BASE + 1;\n          } else {\n            break out;\n          }\n        } else {\n          w = k = xd[xdi];\n          for (digits = 1; k >= 10; k /= 10)\n            digits++;\n          i %= LOG_BASE;\n          j = i - LOG_BASE + digits;\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n        }\n      }\n      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n      if (sd < 1 || !xd[0]) {\n        xd.length = 0;\n        if (roundUp) {\n          sd -= x.e + 1;\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n          x.e = -sd || 0;\n        } else {\n          xd[0] = x.e = 0;\n        }\n        return x;\n      }\n      if (i == 0) {\n        xd.length = xdi;\n        k = 1;\n        xdi--;\n      } else {\n        xd.length = xdi + 1;\n        k = mathpow(10, LOG_BASE - i);\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n      }\n      if (roundUp) {\n        for (; ; ) {\n          if (xdi == 0) {\n            for (i = 1, j = xd[0]; j >= 10; j /= 10)\n              i++;\n            j = xd[0] += k;\n            for (k = 1; j >= 10; j /= 10)\n              k++;\n            if (i != k) {\n              x.e++;\n              if (xd[0] == BASE)\n                xd[0] = 1;\n            }\n            break;\n          } else {\n            xd[xdi] += k;\n            if (xd[xdi] != BASE)\n              break;\n            xd[xdi--] = 0;\n            k = 1;\n          }\n        }\n      }\n      for (i = xd.length; xd[--i] === 0; )\n        xd.pop();\n    }\n  if (external) {\n    if (x.e > Ctor.maxE) {\n      x.d = null;\n      x.e = NaN;\n    } else if (x.e < Ctor.minE) {\n      x.e = 0;\n      x.d = [0];\n    }\n  }\n  return x;\n}\n__name(finalise, \"finalise\");\nfunction finiteToString(x, isExp, sd) {\n  if (!x.isFinite())\n    return nonFiniteToString(x);\n  var k, e = x.e, str = digitsToString(x.d), len = str.length;\n  if (isExp) {\n    if (sd && (k = sd - len) > 0) {\n      str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n    } else if (len > 1) {\n      str = str.charAt(0) + \".\" + str.slice(1);\n    }\n    str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n  } else if (e < 0) {\n    str = \"0.\" + getZeroString(-e - 1) + str;\n    if (sd && (k = sd - len) > 0)\n      str += getZeroString(k);\n  } else if (e >= len) {\n    str += getZeroString(e + 1 - len);\n    if (sd && (k = sd - e - 1) > 0)\n      str = str + \".\" + getZeroString(k);\n  } else {\n    if ((k = e + 1) < len)\n      str = str.slice(0, k) + \".\" + str.slice(k);\n    if (sd && (k = sd - len) > 0) {\n      if (e + 1 === len)\n        str += \".\";\n      str += getZeroString(k);\n    }\n  }\n  return str;\n}\n__name(finiteToString, \"finiteToString\");\nfunction getBase10Exponent(digits, e) {\n  var w = digits[0];\n  for (e *= LOG_BASE; w >= 10; w /= 10)\n    e++;\n  return e;\n}\n__name(getBase10Exponent, \"getBase10Exponent\");\nfunction getLn10(Ctor, sd, pr) {\n  if (sd > LN10_PRECISION) {\n    external = true;\n    if (pr)\n      Ctor.precision = pr;\n    throw Error(precisionLimitExceeded);\n  }\n  return finalise(new Ctor(LN10), sd, 1, true);\n}\n__name(getLn10, \"getLn10\");\nfunction getPi(Ctor, sd, rm) {\n  if (sd > PI_PRECISION)\n    throw Error(precisionLimitExceeded);\n  return finalise(new Ctor(PI), sd, rm, true);\n}\n__name(getPi, \"getPi\");\nfunction getPrecision(digits) {\n  var w = digits.length - 1, len = w * LOG_BASE + 1;\n  w = digits[w];\n  if (w) {\n    for (; w % 10 == 0; w /= 10)\n      len--;\n    for (w = digits[0]; w >= 10; w /= 10)\n      len++;\n  }\n  return len;\n}\n__name(getPrecision, \"getPrecision\");\nfunction getZeroString(k) {\n  var zs = \"\";\n  for (; k--; )\n    zs += \"0\";\n  return zs;\n}\n__name(getZeroString, \"getZeroString\");\nfunction intPow(Ctor, x, n, pr) {\n  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n  external = false;\n  for (; ; ) {\n    if (n % 2) {\n      r = r.times(x);\n      if (truncate(r.d, k))\n        isTruncated = true;\n    }\n    n = mathfloor(n / 2);\n    if (n === 0) {\n      n = r.d.length - 1;\n      if (isTruncated && r.d[n] === 0)\n        ++r.d[n];\n      break;\n    }\n    x = x.times(x);\n    truncate(x.d, k);\n  }\n  external = true;\n  return r;\n}\n__name(intPow, \"intPow\");\nfunction isOdd(n) {\n  return n.d[n.d.length - 1] & 1;\n}\n__name(isOdd, \"isOdd\");\nfunction maxOrMin(Ctor, args, ltgt) {\n  var y, x = new Ctor(args[0]), i = 0;\n  for (; ++i < args.length; ) {\n    y = new Ctor(args[i]);\n    if (!y.s) {\n      x = y;\n      break;\n    } else if (x[ltgt](y)) {\n      x = y;\n    }\n  }\n  return x;\n}\n__name(maxOrMin, \"maxOrMin\");\nfunction naturalExponential(x, sd) {\n  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (!x.d || !x.d[0] || x.e > 17) {\n    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  t = new Ctor(0.03125);\n  while (x.e > -2) {\n    x = x.times(t);\n    k += 5;\n  }\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n  wpr += guard;\n  denominator = pow2 = sum2 = new Ctor(1);\n  Ctor.precision = wpr;\n  for (; ; ) {\n    pow2 = finalise(pow2.times(x), wpr, 1);\n    denominator = denominator.times(++i);\n    t = sum2.plus(divide(pow2, denominator, wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      j = k;\n      while (j--)\n        sum2 = finalise(sum2.times(sum2), wpr, 1);\n      if (sd == null) {\n        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += 10;\n          denominator = pow2 = t = new Ctor(1);\n          i = 0;\n          rep++;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n  }\n}\n__name(naturalExponential, \"naturalExponential\");\nfunction naturalLogarithm(y, sd) {\n  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  Ctor.precision = wpr += guard;\n  c = digitsToString(xd);\n  c0 = c.charAt(0);\n  if (Math.abs(e = x.e) < 15e14) {\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n      x = x.times(y);\n      c = digitsToString(x.d);\n      c0 = c.charAt(0);\n      n++;\n    }\n    e = x.e;\n    if (c0 > 1) {\n      x = new Ctor(\"0.\" + c);\n      e++;\n    } else {\n      x = new Ctor(c0 + \".\" + c.slice(1));\n    }\n  } else {\n    t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n    x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n    Ctor.precision = pr;\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\n  }\n  x1 = x;\n  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n  x2 = finalise(x.times(x), wpr, 1);\n  denominator = 3;\n  for (; ; ) {\n    numerator = finalise(numerator.times(x2), wpr, 1);\n    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      sum2 = sum2.times(2);\n      if (e !== 0)\n        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n      sum2 = divide(sum2, new Ctor(n), wpr, 1);\n      if (sd == null) {\n        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += guard;\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n          x2 = finalise(x.times(x), wpr, 1);\n          denominator = rep = 1;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n    denominator += 2;\n  }\n}\n__name(naturalLogarithm, \"naturalLogarithm\");\nfunction nonFiniteToString(x) {\n  return String(x.s * x.s / 0);\n}\n__name(nonFiniteToString, \"nonFiniteToString\");\nfunction parseDecimal(x, str) {\n  var e, i, len;\n  if ((e = str.indexOf(\".\")) > -1)\n    str = str.replace(\".\", \"\");\n  if ((i = str.search(/e/i)) > 0) {\n    if (e < 0)\n      e = i;\n    e += +str.slice(i + 1);\n    str = str.substring(0, i);\n  } else if (e < 0) {\n    e = str.length;\n  }\n  for (i = 0; str.charCodeAt(i) === 48; i++)\n    ;\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)\n    ;\n  str = str.slice(i, len);\n  if (str) {\n    len -= i;\n    x.e = e = e - i - 1;\n    x.d = [];\n    i = (e + 1) % LOG_BASE;\n    if (e < 0)\n      i += LOG_BASE;\n    if (i < len) {\n      if (i)\n        x.d.push(+str.slice(0, i));\n      for (len -= LOG_BASE; i < len; )\n        x.d.push(+str.slice(i, i += LOG_BASE));\n      str = str.slice(i);\n      i = LOG_BASE - str.length;\n    } else {\n      i -= len;\n    }\n    for (; i--; )\n      str += \"0\";\n    x.d.push(+str);\n    if (external) {\n      if (x.e > x.constructor.maxE) {\n        x.d = null;\n        x.e = NaN;\n      } else if (x.e < x.constructor.minE) {\n        x.e = 0;\n        x.d = [0];\n      }\n    }\n  } else {\n    x.e = 0;\n    x.d = [0];\n  }\n  return x;\n}\n__name(parseDecimal, \"parseDecimal\");\nfunction parseOther(x, str) {\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n  if (str.indexOf(\"_\") > -1) {\n    str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n    if (isDecimal.test(str))\n      return parseDecimal(x, str);\n  } else if (str === \"Infinity\" || str === \"NaN\") {\n    if (!+str)\n      x.s = NaN;\n    x.e = NaN;\n    x.d = null;\n    return x;\n  }\n  if (isHex.test(str)) {\n    base = 16;\n    str = str.toLowerCase();\n  } else if (isBinary.test(str)) {\n    base = 2;\n  } else if (isOctal.test(str)) {\n    base = 8;\n  } else {\n    throw Error(invalidArgument + str);\n  }\n  i = str.search(/p/i);\n  if (i > 0) {\n    p = +str.slice(i + 1);\n    str = str.substring(2, i);\n  } else {\n    str = str.slice(2);\n  }\n  i = str.indexOf(\".\");\n  isFloat = i >= 0;\n  Ctor = x.constructor;\n  if (isFloat) {\n    str = str.replace(\".\", \"\");\n    len = str.length;\n    i = len - i;\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n  }\n  xd = convertBase(str, base, BASE);\n  xe = xd.length - 1;\n  for (i = xe; xd[i] === 0; --i)\n    xd.pop();\n  if (i < 0)\n    return new Ctor(x.s * 0);\n  x.e = getBase10Exponent(xd, xe);\n  x.d = xd;\n  external = false;\n  if (isFloat)\n    x = divide(x, divisor, len * 4);\n  if (p)\n    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n  external = true;\n  return x;\n}\n__name(parseOther, \"parseOther\");\nfunction sine(Ctor, x) {\n  var k, len = x.d.length;\n  if (len < 3) {\n    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n  }\n  k = 1.4 * Math.sqrt(len);\n  k = k > 16 ? 16 : k | 0;\n  x = x.times(1 / tinyPow(5, k));\n  x = taylorSeries(Ctor, 2, x, x);\n  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n  for (; k--; ) {\n    sin2_x = x.times(x);\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n  }\n  return x;\n}\n__name(sine, \"sine\");\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n  external = false;\n  x2 = x.times(x);\n  u = new Ctor(y);\n  for (; ; ) {\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n    t = u.plus(y);\n    if (t.d[k] !== void 0) {\n      for (j = k; t.d[j] === u.d[j] && j--; )\n        ;\n      if (j == -1)\n        break;\n    }\n    j = u;\n    u = y;\n    y = t;\n    t = j;\n    i++;\n  }\n  external = true;\n  t.d.length = k + 1;\n  return t;\n}\n__name(taylorSeries, \"taylorSeries\");\nfunction tinyPow(b, e) {\n  var n = b;\n  while (--e)\n    n *= b;\n  return n;\n}\n__name(tinyPow, \"tinyPow\");\nfunction toLessThanHalfPi(Ctor, x) {\n  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n  x = x.abs();\n  if (x.lte(halfPi)) {\n    quadrant = isNeg ? 4 : 1;\n    return x;\n  }\n  t = x.divToInt(pi);\n  if (t.isZero()) {\n    quadrant = isNeg ? 3 : 2;\n  } else {\n    x = x.minus(t.times(pi));\n    if (x.lte(halfPi)) {\n      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n      return x;\n    }\n    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n  }\n  return x.minus(pi).abs();\n}\n__name(toLessThanHalfPi, \"toLessThanHalfPi\");\nfunction toStringBinary(x, baseOut, sd, rm) {\n  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n  if (isExp) {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  } else {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  }\n  if (!x.isFinite()) {\n    str = nonFiniteToString(x);\n  } else {\n    str = finiteToString(x);\n    i = str.indexOf(\".\");\n    if (isExp) {\n      base = 2;\n      if (baseOut == 16) {\n        sd = sd * 4 - 3;\n      } else if (baseOut == 8) {\n        sd = sd * 3 - 2;\n      }\n    } else {\n      base = baseOut;\n    }\n    if (i >= 0) {\n      str = str.replace(\".\", \"\");\n      y = new Ctor(1);\n      y.e = str.length - i;\n      y.d = convertBase(finiteToString(y), 10, base);\n      y.e = y.d.length;\n    }\n    xd = convertBase(str, 10, base);\n    e = len = xd.length;\n    for (; xd[--len] == 0; )\n      xd.pop();\n    if (!xd[0]) {\n      str = isExp ? \"0p+0\" : \"0\";\n    } else {\n      if (i < 0) {\n        e--;\n      } else {\n        x = new Ctor(x);\n        x.d = xd;\n        x.e = e;\n        x = divide(x, y, sd, rm, 0, base);\n        xd = x.d;\n        e = x.e;\n        roundUp = inexact;\n      }\n      i = xd[sd];\n      k = base / 2;\n      roundUp = roundUp || xd[sd + 1] !== void 0;\n      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n      xd.length = sd;\n      if (roundUp) {\n        for (; ++xd[--sd] > base - 1; ) {\n          xd[sd] = 0;\n          if (!sd) {\n            ++e;\n            xd.unshift(1);\n          }\n        }\n      }\n      for (len = xd.length; !xd[len - 1]; --len)\n        ;\n      for (i = 0, str = \"\"; i < len; i++)\n        str += NUMERALS.charAt(xd[i]);\n      if (isExp) {\n        if (len > 1) {\n          if (baseOut == 16 || baseOut == 8) {\n            i = baseOut == 16 ? 4 : 3;\n            for (--len; len % i; len++)\n              str += \"0\";\n            xd = convertBase(str, base, baseOut);\n            for (len = xd.length; !xd[len - 1]; --len)\n              ;\n            for (i = 1, str = \"1.\"; i < len; i++)\n              str += NUMERALS.charAt(xd[i]);\n          } else {\n            str = str.charAt(0) + \".\" + str.slice(1);\n          }\n        }\n        str = str + (e < 0 ? \"p\" : \"p+\") + e;\n      } else if (e < 0) {\n        for (; ++e; )\n          str = \"0\" + str;\n        str = \"0.\" + str;\n      } else {\n        if (++e > len)\n          for (e -= len; e--; )\n            str += \"0\";\n        else if (e < len)\n          str = str.slice(0, e) + \".\" + str.slice(e);\n      }\n    }\n    str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n  }\n  return x.s < 0 ? \"-\" + str : str;\n}\n__name(toStringBinary, \"toStringBinary\");\nfunction truncate(arr, len) {\n  if (arr.length > len) {\n    arr.length = len;\n    return true;\n  }\n}\n__name(truncate, \"truncate\");\nfunction abs(x) {\n  return new this(x).abs();\n}\n__name(abs, \"abs\");\nfunction acos(x) {\n  return new this(x).acos();\n}\n__name(acos, \"acos\");\nfunction acosh(x) {\n  return new this(x).acosh();\n}\n__name(acosh, \"acosh\");\nfunction add(x, y) {\n  return new this(x).plus(y);\n}\n__name(add, \"add\");\nfunction asin(x) {\n  return new this(x).asin();\n}\n__name(asin, \"asin\");\nfunction asinh(x) {\n  return new this(x).asinh();\n}\n__name(asinh, \"asinh\");\nfunction atan(x) {\n  return new this(x).atan();\n}\n__name(atan, \"atan\");\nfunction atanh(x) {\n  return new this(x).atanh();\n}\n__name(atanh, \"atanh\");\nfunction atan2(y, x) {\n  y = new this(y);\n  x = new this(x);\n  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n  if (!y.s || !x.s) {\n    r = new this(NaN);\n  } else if (!y.d && !x.d) {\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n    r.s = y.s;\n  } else if (!x.d || y.isZero()) {\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n    r.s = y.s;\n  } else if (!y.d || x.isZero()) {\n    r = getPi(this, wpr, 1).times(0.5);\n    r.s = y.s;\n  } else if (x.s < 0) {\n    this.precision = wpr;\n    this.rounding = 1;\n    r = this.atan(divide(y, x, wpr, 1));\n    x = getPi(this, wpr, 1);\n    this.precision = pr;\n    this.rounding = rm;\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\n  } else {\n    r = this.atan(divide(y, x, wpr, 1));\n  }\n  return r;\n}\n__name(atan2, \"atan2\");\nfunction cbrt(x) {\n  return new this(x).cbrt();\n}\n__name(cbrt, \"cbrt\");\nfunction ceil(x) {\n  return finalise(x = new this(x), x.e + 1, 2);\n}\n__name(ceil, \"ceil\");\nfunction clamp(x, min2, max2) {\n  return new this(x).clamp(min2, max2);\n}\n__name(clamp, \"clamp\");\nfunction config(obj) {\n  if (!obj || typeof obj !== \"object\")\n    throw Error(decimalError + \"Object expected\");\n  var i, p, v, useDefaults = obj.defaults === true, ps = [\n    \"precision\",\n    1,\n    MAX_DIGITS,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -EXP_LIMIT,\n    0,\n    \"toExpPos\",\n    0,\n    EXP_LIMIT,\n    \"maxE\",\n    0,\n    EXP_LIMIT,\n    \"minE\",\n    -EXP_LIMIT,\n    0,\n    \"modulo\",\n    0,\n    9\n  ];\n  for (i = 0; i < ps.length; i += 3) {\n    if (p = ps[i], useDefaults)\n      this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])\n        this[p] = v;\n      else\n        throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  if (p = \"crypto\", useDefaults)\n    this[p] = DEFAULTS[p];\n  if ((v = obj[p]) !== void 0) {\n    if (v === true || v === false || v === 0 || v === 1) {\n      if (v) {\n        if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n          this[p] = true;\n        } else {\n          throw Error(cryptoUnavailable);\n        }\n      } else {\n        this[p] = false;\n      }\n    } else {\n      throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  return this;\n}\n__name(config, \"config\");\nfunction cos(x) {\n  return new this(x).cos();\n}\n__name(cos, \"cos\");\nfunction cosh(x) {\n  return new this(x).cosh();\n}\n__name(cosh, \"cosh\");\nfunction clone(obj) {\n  var i, p, ps;\n  function Decimal2(v) {\n    var e, i2, t, x = this;\n    if (!(x instanceof Decimal2))\n      return new Decimal2(v);\n    x.constructor = Decimal2;\n    if (isDecimalInstance(v)) {\n      x.s = v.s;\n      if (external) {\n        if (!v.d || v.e > Decimal2.maxE) {\n          x.e = NaN;\n          x.d = null;\n        } else if (v.e < Decimal2.minE) {\n          x.e = 0;\n          x.d = [0];\n        } else {\n          x.e = v.e;\n          x.d = v.d.slice();\n        }\n      } else {\n        x.e = v.e;\n        x.d = v.d ? v.d.slice() : v.d;\n      }\n      return;\n    }\n    t = typeof v;\n    if (t === \"number\") {\n      if (v === 0) {\n        x.s = 1 / v < 0 ? -1 : 1;\n        x.e = 0;\n        x.d = [0];\n        return;\n      }\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      if (v === ~~v && v < 1e7) {\n        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)\n          e++;\n        if (external) {\n          if (e > Decimal2.maxE) {\n            x.e = NaN;\n            x.d = null;\n          } else if (e < Decimal2.minE) {\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n        } else {\n          x.e = e;\n          x.d = [v];\n        }\n        return;\n      } else if (v * 0 !== 0) {\n        if (!v)\n          x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return;\n      }\n      return parseDecimal(x, v.toString());\n    } else if (t !== \"string\") {\n      throw Error(invalidArgument + v);\n    }\n    if ((i2 = v.charCodeAt(0)) === 45) {\n      v = v.slice(1);\n      x.s = -1;\n    } else {\n      if (i2 === 43)\n        v = v.slice(1);\n      x.s = 1;\n    }\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n  }\n  __name(Decimal2, \"Decimal\");\n  Decimal2.prototype = P;\n  Decimal2.ROUND_UP = 0;\n  Decimal2.ROUND_DOWN = 1;\n  Decimal2.ROUND_CEIL = 2;\n  Decimal2.ROUND_FLOOR = 3;\n  Decimal2.ROUND_HALF_UP = 4;\n  Decimal2.ROUND_HALF_DOWN = 5;\n  Decimal2.ROUND_HALF_EVEN = 6;\n  Decimal2.ROUND_HALF_CEIL = 7;\n  Decimal2.ROUND_HALF_FLOOR = 8;\n  Decimal2.EUCLID = 9;\n  Decimal2.config = Decimal2.set = config;\n  Decimal2.clone = clone;\n  Decimal2.isDecimal = isDecimalInstance;\n  Decimal2.abs = abs;\n  Decimal2.acos = acos;\n  Decimal2.acosh = acosh;\n  Decimal2.add = add;\n  Decimal2.asin = asin;\n  Decimal2.asinh = asinh;\n  Decimal2.atan = atan;\n  Decimal2.atanh = atanh;\n  Decimal2.atan2 = atan2;\n  Decimal2.cbrt = cbrt;\n  Decimal2.ceil = ceil;\n  Decimal2.clamp = clamp;\n  Decimal2.cos = cos;\n  Decimal2.cosh = cosh;\n  Decimal2.div = div;\n  Decimal2.exp = exp;\n  Decimal2.floor = floor;\n  Decimal2.hypot = hypot;\n  Decimal2.ln = ln;\n  Decimal2.log = log;\n  Decimal2.log10 = log10;\n  Decimal2.log2 = log2;\n  Decimal2.max = max;\n  Decimal2.min = min;\n  Decimal2.mod = mod;\n  Decimal2.mul = mul;\n  Decimal2.pow = pow;\n  Decimal2.random = random;\n  Decimal2.round = round;\n  Decimal2.sign = sign;\n  Decimal2.sin = sin;\n  Decimal2.sinh = sinh;\n  Decimal2.sqrt = sqrt;\n  Decimal2.sub = sub;\n  Decimal2.sum = sum;\n  Decimal2.tan = tan;\n  Decimal2.tanh = tanh;\n  Decimal2.trunc = trunc;\n  if (obj === void 0)\n    obj = {};\n  if (obj) {\n    if (obj.defaults !== true) {\n      ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n      for (i = 0; i < ps.length; )\n        if (!obj.hasOwnProperty(p = ps[i++]))\n          obj[p] = this[p];\n    }\n  }\n  Decimal2.config(obj);\n  return Decimal2;\n}\n__name(clone, \"clone\");\nfunction div(x, y) {\n  return new this(x).div(y);\n}\n__name(div, \"div\");\nfunction exp(x) {\n  return new this(x).exp();\n}\n__name(exp, \"exp\");\nfunction floor(x) {\n  return finalise(x = new this(x), x.e + 1, 3);\n}\n__name(floor, \"floor\");\nfunction hypot() {\n  var i, n, t = new this(0);\n  external = false;\n  for (i = 0; i < arguments.length; ) {\n    n = new this(arguments[i++]);\n    if (!n.d) {\n      if (n.s) {\n        external = true;\n        return new this(1 / 0);\n      }\n      t = n;\n    } else if (t.d) {\n      t = t.plus(n.times(n));\n    }\n  }\n  external = true;\n  return t.sqrt();\n}\n__name(hypot, \"hypot\");\nfunction isDecimalInstance(obj) {\n  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n__name(isDecimalInstance, \"isDecimalInstance\");\nfunction ln(x) {\n  return new this(x).ln();\n}\n__name(ln, \"ln\");\nfunction log(x, y) {\n  return new this(x).log(y);\n}\n__name(log, \"log\");\nfunction log2(x) {\n  return new this(x).log(2);\n}\n__name(log2, \"log2\");\nfunction log10(x) {\n  return new this(x).log(10);\n}\n__name(log10, \"log10\");\nfunction max() {\n  return maxOrMin(this, arguments, \"lt\");\n}\n__name(max, \"max\");\nfunction min() {\n  return maxOrMin(this, arguments, \"gt\");\n}\n__name(min, \"min\");\nfunction mod(x, y) {\n  return new this(x).mod(y);\n}\n__name(mod, \"mod\");\nfunction mul(x, y) {\n  return new this(x).mul(y);\n}\n__name(mul, \"mul\");\nfunction pow(x, y) {\n  return new this(x).pow(y);\n}\n__name(pow, \"pow\");\nfunction random(sd) {\n  var d, e, k, n, i = 0, r = new this(1), rd = [];\n  if (sd === void 0)\n    sd = this.precision;\n  else\n    checkInt32(sd, 1, MAX_DIGITS);\n  k = Math.ceil(sd / LOG_BASE);\n  if (!this.crypto) {\n    for (; i < k; )\n      rd[i++] = Math.random() * 1e7 | 0;\n  } else if (crypto.getRandomValues) {\n    d = crypto.getRandomValues(new Uint32Array(k));\n    for (; i < k; ) {\n      n = d[i];\n      if (n >= 429e7) {\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n      } else {\n        rd[i++] = n % 1e7;\n      }\n    }\n  } else if (crypto.randomBytes) {\n    d = crypto.randomBytes(k *= 4);\n    for (; i < k; ) {\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n      if (n >= 214e7) {\n        crypto.randomBytes(4).copy(d, i);\n      } else {\n        rd.push(n % 1e7);\n        i += 4;\n      }\n    }\n    i = k / 4;\n  } else {\n    throw Error(cryptoUnavailable);\n  }\n  k = rd[--i];\n  sd %= LOG_BASE;\n  if (k && sd) {\n    n = mathpow(10, LOG_BASE - sd);\n    rd[i] = (k / n | 0) * n;\n  }\n  for (; rd[i] === 0; i--)\n    rd.pop();\n  if (i < 0) {\n    e = 0;\n    rd = [0];\n  } else {\n    e = -1;\n    for (; rd[0] === 0; e -= LOG_BASE)\n      rd.shift();\n    for (k = 1, n = rd[0]; n >= 10; n /= 10)\n      k++;\n    if (k < LOG_BASE)\n      e -= LOG_BASE - k;\n  }\n  r.e = e;\n  r.d = rd;\n  return r;\n}\n__name(random, \"random\");\nfunction round(x) {\n  return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n__name(round, \"round\");\nfunction sign(x) {\n  x = new this(x);\n  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n__name(sign, \"sign\");\nfunction sin(x) {\n  return new this(x).sin();\n}\n__name(sin, \"sin\");\nfunction sinh(x) {\n  return new this(x).sinh();\n}\n__name(sinh, \"sinh\");\nfunction sqrt(x) {\n  return new this(x).sqrt();\n}\n__name(sqrt, \"sqrt\");\nfunction sub(x, y) {\n  return new this(x).sub(y);\n}\n__name(sub, \"sub\");\nfunction sum() {\n  var i = 0, args = arguments, x = new this(args[i]);\n  external = false;\n  for (; x.s && ++i < args.length; )\n    x = x.plus(args[i]);\n  external = true;\n  return finalise(x, this.precision, this.rounding);\n}\n__name(sum, \"sum\");\nfunction tan(x) {\n  return new this(x).tan();\n}\n__name(tan, \"tan\");\nfunction tanh(x) {\n  return new this(x).tanh();\n}\n__name(tanh, \"tanh\");\nfunction trunc(x) {\n  return finalise(x = new this(x), x.e + 1, 1);\n}\n__name(trunc, \"trunc\");\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\nvar Decimal = P.constructor = clone(DEFAULTS);\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\nvar decimal_default = Decimal;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleC1icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDJCQUEyQjtBQUN2RjtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLGFBQWE7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50L3J1bnRpbWUvaW5kZXgtYnJvd3Nlci5qcz8zNDc5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QyKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QyKTtcblxuLy8gc3JjL3J1bnRpbWUvaW5kZXgtYnJvd3Nlci50c1xudmFyIGluZGV4X2Jyb3dzZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfYnJvd3Nlcl9leHBvcnRzLCB7XG4gIERlY2ltYWw6ICgpID0+IGRlY2ltYWxfZGVmYXVsdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9icm93c2VyX2V4cG9ydHMpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVjaW1hbC5qc0AxMC4zLjEvbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5tanNcbnZhciBFWFBfTElNSVQgPSA5ZTE1O1xudmFyIE1BWF9ESUdJVFMgPSAxZTk7XG52YXIgTlVNRVJBTFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbnZhciBMTjEwID0gXCIyLjMwMjU4NTA5Mjk5NDA0NTY4NDAxNzk5MTQ1NDY4NDM2NDIwNzYwMTEwMTQ4ODYyODc3Mjk3NjAzMzMyNzkwMDk2NzU3MjYwOTY3NzM1MjQ4MDIzNTk5NzIwNTA4OTU5ODI5ODM0MTk2Nzc4NDA0MjI4NjI0ODYzMzQwOTUyNTQ2NTA4MjgwNjc1NjY2NjI4NzM2OTA5ODc4MTY4OTQ4MjkwNzIwODMyNTU1NDY4MDg0Mzc5OTg5NDgyNjIzMzE5ODUyODM5MzUwNTMwODk2NTM3NzczMjYyODg0NjE2MzM2NjIyMjI4NzY5ODIxOTg4Njc0NjU0MzY2NzQ3NDQwNDI0MzI3NDM2NTE1NTA0ODkzNDMxNDkzOTM5MTQ3OTYxOTQwNDQwMDIyMjEwNTEwMTcxNDE3NDgwMDM2ODgwODQwMTI2NDcwODA2ODU1Njc3NDMyMTYyMjgzNTUyMjAxMTQ4MDQ2NjM3MTU2NTkxMjEzNzM0NTA3NDc4NTY5NDc2ODM0NjM2MTY3OTIxMDE4MDY0NDUwNzA2NDgwMDAyNzc1MDI2ODQ5MTY3NDY1NTA1ODY4NTY5MzU2NzM0MjA2NzA1ODExMzY0MjkyMjQ1NTQ0MDU3NTg5MjU3MjQyMDgyNDEzMTQ2OTU2ODkwMTY3NTg5NDAyNTY3NzYzMTEzNTY5MTkyOTIwMzMzNzY1ODcxNDE2NjAyMzAxMDU3MDMwODk2MzQ1NzIwNzU0NDAzNzA4NDc0Njk5NDAxNjgyNjkyODI4MDg0ODExODQyODkzMTQ4NDg1MjQ5NDg2NDQ4NzE5Mjc4MDk2NzYyNzEyNzU3NzUzOTcwMjc2Njg2MDU5NTI0OTY3MTY2NzQxODM0ODU3MDQ0MjI1MDcxOTc5NjUwMDQ3MTQ5NTEwNTA0OTIyMTQ3NzY1Njc2MzY5Mzg2NjI5NzY5Nzk1MjIxMTA3MTgyNjQ1NDk3MzQ3NzI2NjI0MjU3MDk0MjkzMjI1ODI3OTg1MDI1ODU1MDk3ODUyNjUzODMyMDc2MDY3MjYzMTcxNjQzMDk1MDU5OTUwODc4MDc1MjM3MTAzMzMxMDExOTc4NTc1NDczMzE1NDE0MjE4MDg0Mjc1NDM4NjM1OTE3NzgxMTcwNTQzMDk4Mjc0ODIzODUwNDU2NDgwMTkwOTU2MTAyOTkyOTE4MjQzMTgyMzc1MjUzNTc3MDk3NTA1Mzk1NjUxODc2OTc1MTAzNzQ5NzA4ODg2OTIxODAyMDUxODkzMzk1MDcyMzg1MzkyMDUxNDQ2MzQxOTcyNjUyODcyODY5NjUxMTA4NjI1NzE0OTIxOTg4NDk5Nzg3NDg4NzM3NzEzNDU2ODYyMDkxNjcwNThcIjtcbnZhciBQSSA9IFwiMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5XCI7XG52YXIgREVGQVVMVFMgPSB7XG4gIHByZWNpc2lvbjogMjAsXG4gIHJvdW5kaW5nOiA0LFxuICBtb2R1bG86IDEsXG4gIHRvRXhwTmVnOiAtNyxcbiAgdG9FeHBQb3M6IDIxLFxuICBtaW5FOiAtRVhQX0xJTUlULFxuICBtYXhFOiBFWFBfTElNSVQsXG4gIGNyeXB0bzogZmFsc2Vcbn07XG52YXIgaW5leGFjdDtcbnZhciBxdWFkcmFudDtcbnZhciBleHRlcm5hbCA9IHRydWU7XG52YXIgZGVjaW1hbEVycm9yID0gXCJbRGVjaW1hbEVycm9yXSBcIjtcbnZhciBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyBcIkludmFsaWQgYXJndW1lbnQ6IFwiO1xudmFyIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyBcIlByZWNpc2lvbiBsaW1pdCBleGNlZWRlZFwiO1xudmFyIGNyeXB0b1VuYXZhaWxhYmxlID0gZGVjaW1hbEVycm9yICsgXCJjcnlwdG8gdW5hdmFpbGFibGVcIjtcbnZhciB0YWcgPSBcIltvYmplY3QgRGVjaW1hbF1cIjtcbnZhciBtYXRoZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIG1hdGhwb3cgPSBNYXRoLnBvdztcbnZhciBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzSGV4ID0gL14weChbMC05YS1mXSsoXFwuWzAtOWEtZl0qKT98XFwuWzAtOWEtZl0rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNPY3RhbCA9IC9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaTtcbnZhciBCQVNFID0gMWU3O1xudmFyIExPR19CQVNFID0gNztcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBMTjEwX1BSRUNJU0lPTiA9IExOMTAubGVuZ3RoIC0gMTtcbnZhciBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxO1xudmFyIFAgPSB7IHRvU3RyaW5nVGFnOiB0YWcgfTtcblAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gIGlmICh4LnMgPCAwKVxuICAgIHgucyA9IDE7XG4gIHJldHVybiBmaW5hbGlzZSh4KTtcbn07XG5QLmNlaWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAyKTtcbn07XG5QLmNsYW1wZWRUbyA9IFAuY2xhbXAgPSBmdW5jdGlvbihtaW4yLCBtYXgyKSB7XG4gIHZhciBrLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIG1pbjIgPSBuZXcgQ3RvcihtaW4yKTtcbiAgbWF4MiA9IG5ldyBDdG9yKG1heDIpO1xuICBpZiAoIW1pbjIucyB8fCAhbWF4Mi5zKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAobWluMi5ndChtYXgyKSlcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBtYXgyKTtcbiAgayA9IHguY21wKG1pbjIpO1xuICByZXR1cm4gayA8IDAgPyBtaW4yIDogeC5jbXAobWF4MikgPiAwID8gbWF4MiA6IG5ldyBDdG9yKHgpO1xufTtcblAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24oeSkge1xuICB2YXIgaSwgaiwgeGRMLCB5ZEwsIHggPSB0aGlzLCB4ZCA9IHguZCwgeWQgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5kLCB4cyA9IHgucywgeXMgPSB5LnM7XG4gIGlmICgheGQgfHwgIXlkKSB7XG4gICAgcmV0dXJuICF4cyB8fCAheXMgPyBOYU4gOiB4cyAhPT0geXMgPyB4cyA6IHhkID09PSB5ZCA/IDAgOiAheGQgXiB4cyA8IDAgPyAxIDogLTE7XG4gIH1cbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pXG4gICAgcmV0dXJuIHhkWzBdID8geHMgOiB5ZFswXSA/IC15cyA6IDA7XG4gIGlmICh4cyAhPT0geXMpXG4gICAgcmV0dXJuIHhzO1xuICBpZiAoeC5lICE9PSB5LmUpXG4gICAgcmV0dXJuIHguZSA+IHkuZSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgeGRMID0geGQubGVuZ3RoO1xuICB5ZEwgPSB5ZC5sZW5ndGg7XG4gIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcbiAgICBpZiAoeGRbaV0gIT09IHlkW2ldKVxuICAgICAgcmV0dXJuIHhkW2ldID4geWRbaV0gXiB4cyA8IDAgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIHhkTCA9PT0geWRMID8gMCA6IHhkTCA+IHlkTCBeIHhzIDwgMCA/IDEgOiAtMTtcbn07XG5QLmNvc2luZSA9IFAuY29zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmQpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICgheC5kWzBdKVxuICAgIHJldHVybiBuZXcgQ3RvcigxKTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0gY29zaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDMgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLmN1YmVSb290ID0gUC5jYnJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlLCBtLCBuLCByLCByZXAsIHMsIHNkLCB0LCB0MywgdDNwbHVzeCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgcyA9IHgucyAqIG1hdGhwb3coeC5zICogeCwgMSAvIDMpO1xuICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcbiAgICBlID0geC5lO1xuICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMylcbiAgICAgIG4gKz0gcyA9PSAxIHx8IHMgPT0gLTIgPyBcIjBcIiA6IFwiMDBcIjtcbiAgICBzID0gbWF0aHBvdyhuLCAxIC8gMyk7XG4gICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMykgLSAoZSAlIDMgPT0gKGUgPCAwID8gLTEgOiAyKSk7XG4gICAgaWYgKHMgPT0gMSAvIDApIHtcbiAgICAgIG4gPSBcIjVlXCIgKyBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XG4gICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoXCJlXCIpICsgMSkgKyBlO1xuICAgIH1cbiAgICByID0gbmV3IEN0b3Iobik7XG4gICAgci5zID0geC5zO1xuICB9IGVsc2Uge1xuICAgIHIgPSBuZXcgQ3RvcihzLnRvU3RyaW5nKCkpO1xuICB9XG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xuICBmb3IgKDsgOyApIHtcbiAgICB0ID0gcjtcbiAgICB0MyA9IHQudGltZXModCkudGltZXModCk7XG4gICAgdDNwbHVzeCA9IHQzLnBsdXMoeCk7XG4gICAgciA9IGRpdmlkZSh0M3BsdXN4LnBsdXMoeCkudGltZXModCksIHQzcGx1c3gucGx1cyh0MyksIHNkICsgMiwgMSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xuICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xuICAgICAgaWYgKG4gPT0gXCI5OTk5XCIgfHwgIXJlcCAmJiBuID09IFwiNDk5OVwiKSB7XG4gICAgICAgIGlmICghcmVwKSB7XG4gICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xuICAgICAgICAgIGlmICh0LnRpbWVzKHQpLnRpbWVzKHQpLmVxKHgpKSB7XG4gICAgICAgICAgICByID0gdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZCArPSA0O1xuICAgICAgICByZXAgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gXCI1XCIpIHtcbiAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XG4gICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLnRpbWVzKHIpLmVxKHgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcbn07XG5QLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3LCBkID0gdGhpcy5kLCBuID0gTmFOO1xuICBpZiAoZCkge1xuICAgIHcgPSBkLmxlbmd0aCAtIDE7XG4gICAgbiA9ICh3IC0gbWF0aGZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcbiAgICB3ID0gZFt3XTtcbiAgICBpZiAodylcbiAgICAgIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMClcbiAgICAgICAgbi0tO1xuICAgIGlmIChuIDwgMClcbiAgICAgIG4gPSAwO1xuICB9XG4gIHJldHVybiBuO1xufTtcblAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xufTtcblAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIGZpbmFsaXNlKGRpdmlkZSh4LCBuZXcgQ3Rvcih5KSwgMCwgMSwgMSksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcbn07XG5QLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcbn07XG5QLmZsb29yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMyk7XG59O1xuUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XG59O1xuUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24oeSkge1xuICB2YXIgayA9IHRoaXMuY21wKHkpO1xuICByZXR1cm4gayA9PSAxIHx8IGsgPT09IDA7XG59O1xuUC5oeXBlcmJvbGljQ29zaW5lID0gUC5jb3NoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrLCBuLCBwciwgcm0sIGxlbiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBvbmUgPSBuZXcgQ3RvcigxKTtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgucyA/IDEgLyAwIDogTmFOKTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG9uZTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzMikge1xuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XG4gICAgbiA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMTY7XG4gICAgbiA9IFwiMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMFwiO1xuICB9XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyhuKSwgbmV3IEN0b3IoMSksIHRydWUpO1xuICB2YXIgY29zaDJfeCwgaSA9IGssIGQ4ID0gbmV3IEN0b3IoOCk7XG4gIGZvciAoOyBpLS07ICkge1xuICAgIGNvc2gyX3ggPSB4LnRpbWVzKHgpO1xuICAgIHggPSBvbmUubWludXMoY29zaDJfeC50aW1lcyhkOC5taW51cyhjb3NoMl94LnRpbWVzKGQ4KSkpKTtcbiAgfVxuICByZXR1cm4gZmluYWxpc2UoeCwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcbn07XG5QLmh5cGVyYm9saWNTaW5lID0gUC5zaW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrLCBwciwgcm0sIGxlbiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzKSB7XG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XG4gICAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XG4gICAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XG4gICAgdmFyIHNpbmgyX3gsIGQ1ID0gbmV3IEN0b3IoNSksIGQxNiA9IG5ldyBDdG9yKDE2KSwgZDIwID0gbmV3IEN0b3IoMjApO1xuICAgIGZvciAoOyBrLS07ICkge1xuICAgICAgc2luaDJfeCA9IHgudGltZXMoeCk7XG4gICAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbmgyX3gudGltZXMoZDE2LnRpbWVzKHNpbmgyX3gpLnBsdXMoZDIwKSkpKTtcbiAgICB9XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLmh5cGVyYm9saWNUYW5nZW50ID0gUC50YW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgucyk7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNztcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHJldHVybiBkaXZpZGUoeC5zaW5oKCksIHguY29zaCgpLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0pO1xufTtcblAuaW52ZXJzZUNvc2luZSA9IFAuYWNvcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFsZlBpLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIGsgPSB4LmFicygpLmNtcCgxKSwgcHIgPSBDdG9yLnByZWNpc2lvbiwgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoayAhPT0gLTEpIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IHguaXNOZWcoKSA/IGdldFBpKEN0b3IsIHByLCBybSkgOiBuZXcgQ3RvcigwKSA6IG5ldyBDdG9yKE5hTik7XG4gIH1cbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHguYXNpbigpO1xuICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBoYWxmUGkubWludXMoeCk7XG59O1xuUC5pbnZlcnNlSHlwZXJib2xpY0Nvc2luZSA9IFAuYWNvc2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5sdGUoMSkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZXEoMSkgPyAwIDogTmFOKTtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHggPSB4LnRpbWVzKHgpLm1pbnVzKDEpLnNxcnQoKS5wbHVzKHgpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgubG4oKTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljU2luZSA9IFAuYXNpbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMiAqIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeCA9IHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cyh4KTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LmxuKCk7XG59O1xuUC5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgPSBQLmF0YW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHdwciwgeHNkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoeC5lID49IDApXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIHhzZCA9IHguc2QoKTtcbiAgaWYgKE1hdGgubWF4KHhzZCwgcHIpIDwgMiAqIC14LmUgLSAxKVxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgcHIsIHJtLCB0cnVlKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XG4gIHggPSBkaXZpZGUoeC5wbHVzKDEpLCBuZXcgQ3RvcigxKS5taW51cyh4KSwgd3ByICsgcHIsIDEpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LmxuKCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgudGltZXMoMC41KTtcbn07XG5QLmludmVyc2VTaW5lID0gUC5hc2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmUGksIGssIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIGsgPSB4LmFicygpLmNtcCgxKTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoayAhPT0gLTEpIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgICAgIGhhbGZQaS5zID0geC5zO1xuICAgICAgcmV0dXJuIGhhbGZQaTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5kaXYobmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLnBsdXMoMSkpLmF0YW4oKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC50aW1lcygyKTtcbn07XG5QLmludmVyc2VUYW5nZW50ID0gUC5hdGFuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpLCBqLCBrLCBuLCBweCwgdCwgciwgd3ByLCB4MiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XG4gICAgaWYgKCF4LnMpXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpZiAocHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xuICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gICAgICByLnMgPSB4LnM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeC5pc1plcm8oKSkge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgfSBlbHNlIGlmICh4LmFicygpLmVxKDEpICYmIHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcbiAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC4yNSk7XG4gICAgci5zID0geC5zO1xuICAgIHJldHVybiByO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGsgPSBNYXRoLm1pbigyOCwgd3ByIC8gTE9HX0JBU0UgKyAyIHwgMCk7XG4gIGZvciAoaSA9IGs7IGk7IC0taSlcbiAgICB4ID0geC5kaXYoeC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKDEpKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgaiA9IE1hdGguY2VpbCh3cHIgLyBMT0dfQkFTRSk7XG4gIG4gPSAxO1xuICB4MiA9IHgudGltZXMoeCk7XG4gIHIgPSBuZXcgQ3Rvcih4KTtcbiAgcHggPSB4O1xuICBmb3IgKDsgaSAhPT0gLTE7ICkge1xuICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgIHQgPSByLm1pbnVzKHB4LmRpdihuICs9IDIpKTtcbiAgICBweCA9IHB4LnRpbWVzKHgyKTtcbiAgICByID0gdC5wbHVzKHB4LmRpdihuICs9IDIpKTtcbiAgICBpZiAoci5kW2pdICE9PSB2b2lkIDApXG4gICAgICBmb3IgKGkgPSBqOyByLmRbaV0gPT09IHQuZFtpXSAmJiBpLS07IClcbiAgICAgICAgO1xuICB9XG4gIGlmIChrKVxuICAgIHIgPSByLnRpbWVzKDIgPDwgayAtIDEpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xufTtcblAuaXNGaW5pdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5kO1xufTtcblAuaXNJbnRlZ2VyID0gUC5pc0ludCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLmQgJiYgbWF0aGZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuZC5sZW5ndGggLSAyO1xufTtcblAuaXNOYU4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnM7XG59O1xuUC5pc05lZ2F0aXZlID0gUC5pc05lZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zIDwgMDtcbn07XG5QLmlzUG9zaXRpdmUgPSBQLmlzUG9zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPiAwO1xufTtcblAuaXNaZXJvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuZCAmJiB0aGlzLmRbMF0gPT09IDA7XG59O1xuUC5sZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XG59O1xuUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24oeSkge1xuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xufTtcblAubG9nYXJpdGhtID0gUC5sb2cgPSBmdW5jdGlvbihiYXNlKSB7XG4gIHZhciBpc0Jhc2UxMCwgZCwgZGVub21pbmF0b3IsIGssIGluZiwgbnVtLCBzZCwgciwgYXJnID0gdGhpcywgQ3RvciA9IGFyZy5jb25zdHJ1Y3RvciwgcHIgPSBDdG9yLnByZWNpc2lvbiwgcm0gPSBDdG9yLnJvdW5kaW5nLCBndWFyZCA9IDU7XG4gIGlmIChiYXNlID09IG51bGwpIHtcbiAgICBiYXNlID0gbmV3IEN0b3IoMTApO1xuICAgIGlzQmFzZTEwID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gbmV3IEN0b3IoYmFzZSk7XG4gICAgZCA9IGJhc2UuZDtcbiAgICBpZiAoYmFzZS5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBiYXNlLmVxKDEpKVxuICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgaXNCYXNlMTAgPSBiYXNlLmVxKDEwKTtcbiAgfVxuICBkID0gYXJnLmQ7XG4gIGlmIChhcmcucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYXJnLmVxKDEpKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XG4gIH1cbiAgaWYgKGlzQmFzZTEwKSB7XG4gICAgaWYgKGQubGVuZ3RoID4gMSkge1xuICAgICAgaW5mID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrID0gZFswXTsgayAlIDEwID09PSAwOyApXG4gICAgICAgIGsgLz0gMTA7XG4gICAgICBpbmYgPSBrICE9PSAxO1xuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzZCA9IHByICsgZ3VhcmQ7XG4gIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XG4gIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XG4gIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgPSBwciwgcm0pKSB7XG4gICAgZG8ge1xuICAgICAgc2QgKz0gMTA7XG4gICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xuICAgICAgZGVub21pbmF0b3IgPSBpc0Jhc2UxMCA/IGdldExuMTAoQ3Rvciwgc2QgKyAxMCkgOiBuYXR1cmFsTG9nYXJpdGhtKGJhc2UsIHNkKTtcbiAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICAgICAgaWYgKCFpbmYpIHtcbiAgICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKGsgKyAxLCBrICsgMTUpICsgMSA9PSAxZTE0KSB7XG4gICAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgKz0gMTAsIHJtKSk7XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcbn07XG5QLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBkLCBlLCBpLCBqLCBrLCBsZW4sIHByLCBybSwgeGQsIHhlLCB4TFR5LCB5ZCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB5ID0gbmV3IEN0b3IoeSk7XG4gIGlmICgheC5kIHx8ICF5LmQpIHtcbiAgICBpZiAoIXgucyB8fCAheS5zKVxuICAgICAgeSA9IG5ldyBDdG9yKE5hTik7XG4gICAgZWxzZSBpZiAoeC5kKVxuICAgICAgeS5zID0gLXkucztcbiAgICBlbHNlXG4gICAgICB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyAhPT0geS5zID8geCA6IE5hTik7XG4gICAgcmV0dXJuIHk7XG4gIH1cbiAgaWYgKHgucyAhPSB5LnMpIHtcbiAgICB5LnMgPSAteS5zO1xuICAgIHJldHVybiB4LnBsdXMoeSk7XG4gIH1cbiAgeGQgPSB4LmQ7XG4gIHlkID0geS5kO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XG4gICAgaWYgKHlkWzBdKVxuICAgICAgeS5zID0gLXkucztcbiAgICBlbHNlIGlmICh4ZFswXSlcbiAgICAgIHkgPSBuZXcgQ3Rvcih4KTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xuICB9XG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICB4ZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XG4gIHhkID0geGQuc2xpY2UoKTtcbiAgayA9IHhlIC0gZTtcbiAgaWYgKGspIHtcbiAgICB4TFR5ID0gayA8IDA7XG4gICAgaWYgKHhMVHkpIHtcbiAgICAgIGQgPSB4ZDtcbiAgICAgIGsgPSAtaztcbiAgICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHlkO1xuICAgICAgZSA9IHhlO1xuICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgIH1cbiAgICBpID0gTWF0aC5tYXgoTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpLCBsZW4pICsgMjtcbiAgICBpZiAoayA+IGkpIHtcbiAgICAgIGsgPSBpO1xuICAgICAgZC5sZW5ndGggPSAxO1xuICAgIH1cbiAgICBkLnJldmVyc2UoKTtcbiAgICBmb3IgKGkgPSBrOyBpLS07IClcbiAgICAgIGQucHVzaCgwKTtcbiAgICBkLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBpID0geGQubGVuZ3RoO1xuICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICB4TFR5ID0gaSA8IGxlbjtcbiAgICBpZiAoeExUeSlcbiAgICAgIGxlbiA9IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoeGRbaV0gIT0geWRbaV0pIHtcbiAgICAgICAgeExUeSA9IHhkW2ldIDwgeWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBrID0gMDtcbiAgfVxuICBpZiAoeExUeSkge1xuICAgIGQgPSB4ZDtcbiAgICB4ZCA9IHlkO1xuICAgIHlkID0gZDtcbiAgICB5LnMgPSAteS5zO1xuICB9XG4gIGxlbiA9IHhkLmxlbmd0aDtcbiAgZm9yIChpID0geWQubGVuZ3RoIC0gbGVuOyBpID4gMDsgLS1pKVxuICAgIHhkW2xlbisrXSA9IDA7XG4gIGZvciAoaSA9IHlkLmxlbmd0aDsgaSA+IGs7ICkge1xuICAgIGlmICh4ZFstLWldIDwgeWRbaV0pIHtcbiAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDsgKVxuICAgICAgICB4ZFtqXSA9IEJBU0UgLSAxO1xuICAgICAgLS14ZFtqXTtcbiAgICAgIHhkW2ldICs9IEJBU0U7XG4gICAgfVxuICAgIHhkW2ldIC09IHlkW2ldO1xuICB9XG4gIGZvciAoOyB4ZFstLWxlbl0gPT09IDA7IClcbiAgICB4ZC5wb3AoKTtcbiAgZm9yICg7IHhkWzBdID09PSAwOyB4ZC5zaGlmdCgpKVxuICAgIC0tZTtcbiAgaWYgKCF4ZFswXSlcbiAgICByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xuICB5LmQgPSB4ZDtcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbn07XG5QLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24oeSkge1xuICB2YXIgcSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB5ID0gbmV3IEN0b3IoeSk7XG4gIGlmICgheC5kIHx8ICF5LnMgfHwgeS5kICYmICF5LmRbMF0pXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICgheS5kIHx8IHguZCAmJiAheC5kWzBdKSB7XG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XG4gIH1cbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgaWYgKEN0b3IubW9kdWxvID09IDkpIHtcbiAgICBxID0gZGl2aWRlKHgsIHkuYWJzKCksIDAsIDMsIDEpO1xuICAgIHEucyAqPSB5LnM7XG4gIH0gZWxzZSB7XG4gICAgcSA9IGRpdmlkZSh4LCB5LCAwLCBDdG9yLm1vZHVsbywgMSk7XG4gIH1cbiAgcSA9IHEudGltZXMoeSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHgubWludXMocSk7XG59O1xuUC5uYXR1cmFsRXhwb25lbnRpYWwgPSBQLmV4cCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmF0dXJhbEV4cG9uZW50aWFsKHRoaXMpO1xufTtcblAubmF0dXJhbExvZ2FyaXRobSA9IFAubG4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5hdHVyYWxMb2dhcml0aG0odGhpcyk7XG59O1xuUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgeC5zID0gLXgucztcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xufTtcblAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24oeSkge1xuICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeSA9IG5ldyBDdG9yKHkpO1xuICBpZiAoIXguZCB8fCAheS5kKSB7XG4gICAgaWYgKCF4LnMgfHwgIXkucylcbiAgICAgIHkgPSBuZXcgQ3RvcihOYU4pO1xuICAgIGVsc2UgaWYgKCF4LmQpXG4gICAgICB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyA9PT0geS5zID8geCA6IE5hTik7XG4gICAgcmV0dXJuIHk7XG4gIH1cbiAgaWYgKHgucyAhPSB5LnMpIHtcbiAgICB5LnMgPSAteS5zO1xuICAgIHJldHVybiB4Lm1pbnVzKHkpO1xuICB9XG4gIHhkID0geC5kO1xuICB5ZCA9IHkuZDtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xuICAgIGlmICgheWRbMF0pXG4gICAgICB5ID0gbmV3IEN0b3IoeCk7XG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG4gIH1cbiAgayA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICB4ZCA9IHhkLnNsaWNlKCk7XG4gIGkgPSBrIC0gZTtcbiAgaWYgKGkpIHtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGQgPSB4ZDtcbiAgICAgIGkgPSAtaTtcbiAgICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHlkO1xuICAgICAgZSA9IGs7XG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgfVxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XG4gICAgbGVuID0gayA+IGxlbiA/IGsgKyAxIDogbGVuICsgMTtcbiAgICBpZiAoaSA+IGxlbikge1xuICAgICAgaSA9IGxlbjtcbiAgICAgIGQubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgZC5yZXZlcnNlKCk7XG4gICAgZm9yICg7IGktLTsgKVxuICAgICAgZC5wdXNoKDApO1xuICAgIGQucmV2ZXJzZSgpO1xuICB9XG4gIGxlbiA9IHhkLmxlbmd0aDtcbiAgaSA9IHlkLmxlbmd0aDtcbiAgaWYgKGxlbiAtIGkgPCAwKSB7XG4gICAgaSA9IGxlbjtcbiAgICBkID0geWQ7XG4gICAgeWQgPSB4ZDtcbiAgICB4ZCA9IGQ7XG4gIH1cbiAgZm9yIChjYXJyeSA9IDA7IGk7ICkge1xuICAgIGNhcnJ5ID0gKHhkWy0taV0gPSB4ZFtpXSArIHlkW2ldICsgY2FycnkpIC8gQkFTRSB8IDA7XG4gICAgeGRbaV0gJT0gQkFTRTtcbiAgfVxuICBpZiAoY2FycnkpIHtcbiAgICB4ZC51bnNoaWZ0KGNhcnJ5KTtcbiAgICArK2U7XG4gIH1cbiAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7IHhkWy0tbGVuXSA9PSAwOyApXG4gICAgeGQucG9wKCk7XG4gIHkuZCA9IHhkO1xuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xufTtcblAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uKHopIHtcbiAgdmFyIGssIHggPSB0aGlzO1xuICBpZiAoeiAhPT0gdm9pZCAwICYmIHogIT09ICEheiAmJiB6ICE9PSAxICYmIHogIT09IDApXG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgeik7XG4gIGlmICh4LmQpIHtcbiAgICBrID0gZ2V0UHJlY2lzaW9uKHguZCk7XG4gICAgaWYgKHogJiYgeC5lICsgMSA+IGspXG4gICAgICBrID0geC5lICsgMTtcbiAgfSBlbHNlIHtcbiAgICBrID0gTmFOO1xuICB9XG4gIHJldHVybiBrO1xufTtcblAucm91bmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCB4LmUgKyAxLCBDdG9yLnJvdW5kaW5nKTtcbn07XG5QLnNpbmUgPSBQLnNpbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIExPR19CQVNFO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID4gMiA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbSwgbiwgc2QsIHIsIHJlcCwgdCwgeCA9IHRoaXMsIGQgPSB4LmQsIGUgPSB4LmUsIHMgPSB4LnMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAocyAhPT0gMSB8fCAhZCB8fCAhZFswXSkge1xuICAgIHJldHVybiBuZXcgQ3RvcighcyB8fCBzIDwgMCAmJiAoIWQgfHwgZFswXSkgPyBOYU4gOiBkID8geCA6IDEgLyAwKTtcbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzID0gTWF0aC5zcXJ0KCt4KTtcbiAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XG4gICAgbiA9IGRpZ2l0c1RvU3RyaW5nKGQpO1xuICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMClcbiAgICAgIG4gKz0gXCIwXCI7XG4gICAgcyA9IE1hdGguc3FydChuKTtcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XG4gICAgaWYgKHMgPT0gMSAvIDApIHtcbiAgICAgIG4gPSBcIjVlXCIgKyBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XG4gICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoXCJlXCIpICsgMSkgKyBlO1xuICAgIH1cbiAgICByID0gbmV3IEN0b3Iobik7XG4gIH0gZWxzZSB7XG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XG4gIH1cbiAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XG4gIGZvciAoOyA7ICkge1xuICAgIHQgPSByO1xuICAgIHIgPSB0LnBsdXMoZGl2aWRlKHgsIHQsIHNkICsgMiwgMSkpLnRpbWVzKDAuNSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xuICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xuICAgICAgaWYgKG4gPT0gXCI5OTk5XCIgfHwgIXJlcCAmJiBuID09IFwiNDk5OVwiKSB7XG4gICAgICAgIGlmICghcmVwKSB7XG4gICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xuICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XG4gICAgICAgICAgICByID0gdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZCArPSA0O1xuICAgICAgICByZXAgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gXCI1XCIpIHtcbiAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XG4gICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcbn07XG5QLnRhbmdlbnQgPSBQLnRhbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDEwO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHguc2luKCk7XG4gIHgucyA9IDE7XG4gIHggPSBkaXZpZGUoeCwgbmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLCBwciArIDEwLCAwKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSA0ID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG59O1xuUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24oeSkge1xuICB2YXIgY2FycnksIGUsIGksIGssIHIsIHJMLCB0LCB4ZEwsIHlkTCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCB4ZCA9IHguZCwgeWQgPSAoeSA9IG5ldyBDdG9yKHkpKS5kO1xuICB5LnMgKj0geC5zO1xuICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKCF5LnMgfHwgeGQgJiYgIXhkWzBdICYmICF5ZCB8fCB5ZCAmJiAheWRbMF0gJiYgIXhkID8gTmFOIDogIXhkIHx8ICF5ZCA/IHkucyAvIDAgOiB5LnMgKiAwKTtcbiAgfVxuICBlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKSArIG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIHhkTCA9IHhkLmxlbmd0aDtcbiAgeWRMID0geWQubGVuZ3RoO1xuICBpZiAoeGRMIDwgeWRMKSB7XG4gICAgciA9IHhkO1xuICAgIHhkID0geWQ7XG4gICAgeWQgPSByO1xuICAgIHJMID0geGRMO1xuICAgIHhkTCA9IHlkTDtcbiAgICB5ZEwgPSByTDtcbiAgfVxuICByID0gW107XG4gIHJMID0geGRMICsgeWRMO1xuICBmb3IgKGkgPSByTDsgaS0tOyApXG4gICAgci5wdXNoKDApO1xuICBmb3IgKGkgPSB5ZEw7IC0taSA+PSAwOyApIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChrID0geGRMICsgaTsgayA+IGk7ICkge1xuICAgICAgdCA9IHJba10gKyB5ZFtpXSAqIHhkW2sgLSBpIC0gMV0gKyBjYXJyeTtcbiAgICAgIHJbay0tXSA9IHQgJSBCQVNFIHwgMDtcbiAgICAgIGNhcnJ5ID0gdCAvIEJBU0UgfCAwO1xuICAgIH1cbiAgICByW2tdID0gKHJba10gKyBjYXJyeSkgJSBCQVNFIHwgMDtcbiAgfVxuICBmb3IgKDsgIXJbLS1yTF07IClcbiAgICByLnBvcCgpO1xuICBpZiAoY2FycnkpXG4gICAgKytlO1xuICBlbHNlXG4gICAgci5zaGlmdCgpO1xuICB5LmQgPSByO1xuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudChyLCBlKTtcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpIDogeTtcbn07XG5QLnRvQmluYXJ5ID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAyLCBzZCwgcm0pO1xufTtcblAudG9EZWNpbWFsUGxhY2VzID0gUC50b0RQID0gZnVuY3Rpb24oZHAsIHJtKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHggPSBuZXcgQ3Rvcih4KTtcbiAgaWYgKGRwID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHg7XG4gIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICBpZiAocm0gPT09IHZvaWQgMClcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGVsc2VcbiAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIGRwICsgeC5lICsgMSwgcm0pO1xufTtcblAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICB2YXIgc3RyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIDEsIHJtKTtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlLCBkcCArIDEpO1xuICB9XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRvRml4ZWQgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHN0ciwgeSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoZHAgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2VcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIHkgPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeSwgZmFsc2UsIGRwICsgeS5lICsgMSk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uKG1heEQpIHtcbiAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGssIG4sIG4wLCBuMSwgcHIsIHEsIHIsIHggPSB0aGlzLCB4ZCA9IHguZCwgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheGQpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBuMSA9IGQwID0gbmV3IEN0b3IoMSk7XG4gIGQxID0gbjAgPSBuZXcgQ3RvcigwKTtcbiAgZCA9IG5ldyBDdG9yKGQxKTtcbiAgZSA9IGQuZSA9IGdldFByZWNpc2lvbih4ZCkgLSB4LmUgLSAxO1xuICBrID0gZSAlIExPR19CQVNFO1xuICBkLmRbMF0gPSBtYXRocG93KDEwLCBrIDwgMCA/IExPR19CQVNFICsgayA6IGspO1xuICBpZiAobWF4RCA9PSBudWxsKSB7XG4gICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xuICB9IGVsc2Uge1xuICAgIG4gPSBuZXcgQ3RvcihtYXhEKTtcbiAgICBpZiAoIW4uaXNJbnQoKSB8fCBuLmx0KG4xKSlcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG4pO1xuICAgIG1heEQgPSBuLmd0KGQpID8gZSA+IDAgPyBkIDogbjEgOiBuO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIG4gPSBuZXcgQ3RvcihkaWdpdHNUb1N0cmluZyh4ZCkpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBDdG9yLnByZWNpc2lvbiA9IGUgPSB4ZC5sZW5ndGggKiBMT0dfQkFTRSAqIDI7XG4gIGZvciAoOyA7ICkge1xuICAgIHEgPSBkaXZpZGUobiwgZCwgMCwgMSwgMSk7XG4gICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcbiAgICBpZiAoZDIuY21wKG1heEQpID09IDEpXG4gICAgICBicmVhaztcbiAgICBkMCA9IGQxO1xuICAgIGQxID0gZDI7XG4gICAgZDIgPSBuMTtcbiAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMikpO1xuICAgIG4wID0gZDI7XG4gICAgZDIgPSBkO1xuICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIpKTtcbiAgICBuID0gZDI7XG4gIH1cbiAgZDIgPSBkaXZpZGUobWF4RC5taW51cyhkMCksIGQxLCAwLCAxLCAxKTtcbiAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XG4gIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xuICBuMC5zID0gbjEucyA9IHgucztcbiAgciA9IGRpdmlkZShuMSwgZDEsIGUsIDEpLm1pbnVzKHgpLmFicygpLmNtcChkaXZpZGUobjAsIGQwLCBlLCAxKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gcjtcbn07XG5QLnRvSGV4YWRlY2ltYWwgPSBQLnRvSGV4ID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcbn07XG5QLnRvTmVhcmVzdCA9IGZ1bmN0aW9uKHksIHJtKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHggPSBuZXcgQ3Rvcih4KTtcbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIGlmICgheC5kKVxuICAgICAgcmV0dXJuIHg7XG4gICAgeSA9IG5ldyBDdG9yKDEpO1xuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgfSBlbHNlIHtcbiAgICB5ID0gbmV3IEN0b3IoeSk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApIHtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgfVxuICAgIGlmICgheC5kKVxuICAgICAgcmV0dXJuIHkucyA/IHggOiB5O1xuICAgIGlmICgheS5kKSB7XG4gICAgICBpZiAoeS5zKVxuICAgICAgICB5LnMgPSB4LnM7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gIH1cbiAgaWYgKHkuZFswXSkge1xuICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgeCA9IGRpdmlkZSh4LCB5LCAwLCBybSwgMSkudGltZXMoeSk7XG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgIGZpbmFsaXNlKHgpO1xuICB9IGVsc2Uge1xuICAgIHkucyA9IHgucztcbiAgICB4ID0geTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5QLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiArdGhpcztcbn07XG5QLnRvT2N0YWwgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDgsIHNkLCBybSk7XG59O1xuUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBlLCBrLCBwciwgciwgcm0sIHMsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgeW4gPSArKHkgPSBuZXcgQ3Rvcih5KSk7XG4gIGlmICgheC5kIHx8ICF5LmQgfHwgIXguZFswXSB8fCAheS5kWzBdKVxuICAgIHJldHVybiBuZXcgQ3RvcihtYXRocG93KCt4LCB5bikpO1xuICB4ID0gbmV3IEN0b3IoeCk7XG4gIGlmICh4LmVxKDEpKVxuICAgIHJldHVybiB4O1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICh5LmVxKDEpKVxuICAgIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0pO1xuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgaWYgKGUgPj0geS5kLmxlbmd0aCAtIDEgJiYgKGsgPSB5biA8IDAgPyAteW4gOiB5bikgPD0gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHIgPSBpbnRQb3coQ3RvciwgeCwgaywgcHIpO1xuICAgIHJldHVybiB5LnMgPCAwID8gbmV3IEN0b3IoMSkuZGl2KHIpIDogZmluYWxpc2UociwgcHIsIHJtKTtcbiAgfVxuICBzID0geC5zO1xuICBpZiAocyA8IDApIHtcbiAgICBpZiAoZSA8IHkuZC5sZW5ndGggLSAxKVxuICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgaWYgKCh5LmRbZV0gJiAxKSA9PSAwKVxuICAgICAgcyA9IDE7XG4gICAgaWYgKHguZSA9PSAwICYmIHguZFswXSA9PSAxICYmIHguZC5sZW5ndGggPT0gMSkge1xuICAgICAgeC5zID0gcztcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfVxuICBrID0gbWF0aHBvdygreCwgeW4pO1xuICBlID0gayA9PSAwIHx8ICFpc0Zpbml0ZShrKSA/IG1hdGhmbG9vcih5biAqIChNYXRoLmxvZyhcIjAuXCIgKyBkaWdpdHNUb1N0cmluZyh4LmQpKSAvIE1hdGguTE4xMCArIHguZSArIDEpKSA6IG5ldyBDdG9yKGsgKyBcIlwiKS5lO1xuICBpZiAoZSA+IEN0b3IubWF4RSArIDEgfHwgZSA8IEN0b3IubWluRSAtIDEpXG4gICAgcmV0dXJuIG5ldyBDdG9yKGUgPiAwID8gcyAvIDAgOiAwKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgQ3Rvci5yb3VuZGluZyA9IHgucyA9IDE7XG4gIGsgPSBNYXRoLm1pbigxMiwgKGUgKyBcIlwiKS5sZW5ndGgpO1xuICByID0gbmF0dXJhbEV4cG9uZW50aWFsKHkudGltZXMobmF0dXJhbExvZ2FyaXRobSh4LCBwciArIGspKSwgcHIpO1xuICBpZiAoci5kKSB7XG4gICAgciA9IGZpbmFsaXNlKHIsIHByICsgNSwgMSk7XG4gICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBwciwgcm0pKSB7XG4gICAgICBlID0gcHIgKyAxMDtcbiAgICAgIHIgPSBmaW5hbGlzZShuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIGUgKyBrKSksIGUpLCBlICsgNSwgMSk7XG4gICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UocHIgKyAxLCBwciArIDE1KSArIDEgPT0gMWUxNCkge1xuICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgci5zID0gcztcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xufTtcblAudG9QcmVjaXNpb24gPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgdmFyIHN0ciwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoc2QgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlXG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgc2QgPD0geC5lIHx8IHguZSA8PSBDdG9yLnRvRXhwTmVnLCBzZCk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9TaWduaWZpY2FudERpZ2l0cyA9IFAudG9TRCA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoc2QgPT09IHZvaWQgMCkge1xuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2VcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICB9XG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcbn07XG5QLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDEpO1xufTtcblAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcbiAgcmV0dXJuIHguaXNOZWcoKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcbmZ1bmN0aW9uIGRpZ2l0c1RvU3RyaW5nKGQpIHtcbiAgdmFyIGksIGssIHdzLCBpbmRleE9mTGFzdFdvcmQgPSBkLmxlbmd0aCAtIDEsIHN0ciA9IFwiXCIsIHcgPSBkWzBdO1xuICBpZiAoaW5kZXhPZkxhc3RXb3JkID4gMCkge1xuICAgIHN0ciArPSB3O1xuICAgIGZvciAoaSA9IDE7IGkgPCBpbmRleE9mTGFzdFdvcmQ7IGkrKykge1xuICAgICAgd3MgPSBkW2ldICsgXCJcIjtcbiAgICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcbiAgICAgIGlmIChrKVxuICAgICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgICAgIHN0ciArPSB3cztcbiAgICB9XG4gICAgdyA9IGRbaV07XG4gICAgd3MgPSB3ICsgXCJcIjtcbiAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XG4gICAgaWYgKGspXG4gICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgfSBlbHNlIGlmICh3ID09PSAwKSB7XG4gICAgcmV0dXJuIFwiMFwiO1xuICB9XG4gIGZvciAoOyB3ICUgMTAgPT09IDA7IClcbiAgICB3IC89IDEwO1xuICByZXR1cm4gc3RyICsgdztcbn1cbl9fbmFtZShkaWdpdHNUb1N0cmluZywgXCJkaWdpdHNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGNoZWNrSW50MzIoaSwgbWluMiwgbWF4Mikge1xuICBpZiAoaSAhPT0gfn5pIHx8IGkgPCBtaW4yIHx8IGkgPiBtYXgyKSB7XG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgaSk7XG4gIH1cbn1cbl9fbmFtZShjaGVja0ludDMyLCBcImNoZWNrSW50MzJcIik7XG5mdW5jdGlvbiBjaGVja1JvdW5kaW5nRGlnaXRzKGQsIGksIHJtLCByZXBlYXRpbmcpIHtcbiAgdmFyIGRpLCBrLCByLCByZDtcbiAgZm9yIChrID0gZFswXTsgayA+PSAxMDsgayAvPSAxMClcbiAgICAtLWk7XG4gIGlmICgtLWkgPCAwKSB7XG4gICAgaSArPSBMT0dfQkFTRTtcbiAgICBkaSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcbiAgICBpICU9IExPR19CQVNFO1xuICB9XG4gIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xuICByZCA9IGRbZGldICUgayB8IDA7XG4gIGlmIChyZXBlYXRpbmcgPT0gbnVsbCkge1xuICAgIGlmIChpIDwgMykge1xuICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgcmQgPSByZCAvIDEwMCB8IDA7XG4gICAgICBlbHNlIGlmIChpID09IDEpXG4gICAgICAgIHJkID0gcmQgLyAxMCB8IDA7XG4gICAgICByID0gcm0gPCA0ICYmIHJkID09IDk5OTk5IHx8IHJtID4gMyAmJiByZCA9PSA0OTk5OSB8fCByZCA9PSA1ZTQgfHwgcmQgPT0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IChybSA8IDQgJiYgcmQgKyAxID09IGsgfHwgcm0gPiAzICYmIHJkICsgMSA9PSBrIC8gMikgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMikgLSAxIHx8IChyZCA9PSBrIC8gMiB8fCByZCA9PSAwKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpIDwgNCkge1xuICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgcmQgPSByZCAvIDFlMyB8IDA7XG4gICAgICBlbHNlIGlmIChpID09IDEpXG4gICAgICAgIHJkID0gcmQgLyAxMDAgfCAwO1xuICAgICAgZWxzZSBpZiAoaSA9PSAyKVxuICAgICAgICByZCA9IHJkIC8gMTAgfCAwO1xuICAgICAgciA9IChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCA9PSA5OTk5IHx8ICFyZXBlYXRpbmcgJiYgcm0gPiAzICYmIHJkID09IDQ5OTk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAoKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkICsgMSA9PSBrIHx8ICFyZXBlYXRpbmcgJiYgcm0gPiAzICYmIHJkICsgMSA9PSBrIC8gMikgJiYgKGRbZGkgKyAxXSAvIGsgLyAxZTMgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMykgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cbl9fbmFtZShjaGVja1JvdW5kaW5nRGlnaXRzLCBcImNoZWNrUm91bmRpbmdEaWdpdHNcIik7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZShzdHIsIGJhc2VJbiwgYmFzZU91dCkge1xuICB2YXIgaiwgYXJyID0gWzBdLCBhcnJMLCBpID0gMCwgc3RyTCA9IHN0ci5sZW5ndGg7XG4gIGZvciAoOyBpIDwgc3RyTDsgKSB7XG4gICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyApXG4gICAgICBhcnJbYXJyTF0gKj0gYmFzZUluO1xuICAgIGFyclswXSArPSBOVU1FUkFMUy5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XG4gICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XG4gICAgICAgIGlmIChhcnJbaiArIDFdID09PSB2b2lkIDApXG4gICAgICAgICAgYXJyW2ogKyAxXSA9IDA7XG4gICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XG4gICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLnJldmVyc2UoKTtcbn1cbl9fbmFtZShjb252ZXJ0QmFzZSwgXCJjb252ZXJ0QmFzZVwiKTtcbmZ1bmN0aW9uIGNvc2luZShDdG9yLCB4KSB7XG4gIHZhciBrLCBsZW4sIHk7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiB4O1xuICBsZW4gPSB4LmQubGVuZ3RoO1xuICBpZiAobGVuIDwgMzIpIHtcbiAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xuICAgIHkgPSAoMSAvIHRpbnlQb3coNCwgaykpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgayA9IDE2O1xuICAgIHkgPSBcIjIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTBcIjtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiArPSBrO1xuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMoeSksIG5ldyBDdG9yKDEpKTtcbiAgZm9yICh2YXIgaSA9IGs7IGktLTsgKSB7XG4gICAgdmFyIGNvczJ4ID0geC50aW1lcyh4KTtcbiAgICB4ID0gY29zMngudGltZXMoY29zMngpLm1pbnVzKGNvczJ4KS50aW1lcyg4KS5wbHVzKDEpO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uIC09IGs7XG4gIHJldHVybiB4O1xufVxuX19uYW1lKGNvc2luZSwgXCJjb3NpbmVcIik7XG52YXIgZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG11bHRpcGx5SW50ZWdlcih4LCBrLCBiYXNlKSB7XG4gICAgdmFyIHRlbXAsIGNhcnJ5ID0gMCwgaSA9IHgubGVuZ3RoO1xuICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOyApIHtcbiAgICAgIHRlbXAgPSB4W2ldICogayArIGNhcnJ5O1xuICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlIHwgMDtcbiAgICAgIGNhcnJ5ID0gdGVtcCAvIGJhc2UgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkpXG4gICAgICB4LnVuc2hpZnQoY2FycnkpO1xuICAgIHJldHVybiB4O1xuICB9XG4gIF9fbmFtZShtdWx0aXBseUludGVnZXIsIFwibXVsdGlwbHlJbnRlZ2VyXCIpO1xuICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xuICAgIHZhciBpLCByO1xuICAgIGlmIChhTCAhPSBiTCkge1xuICAgICAgciA9IGFMID4gYkwgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IHIgPSAwOyBpIDwgYUw7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XG4gICAgICAgICAgciA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIF9fbmFtZShjb21wYXJlLCBcImNvbXBhcmVcIik7XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBhTC0tOyApIHtcbiAgICAgIGFbYUxdIC09IGk7XG4gICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xuICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XG4gICAgfVxuICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IClcbiAgICAgIGEuc2hpZnQoKTtcbiAgfVxuICBfX25hbWUoc3VidHJhY3QsIFwic3VidHJhY3RcIik7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5LCBwciwgcm0sIGRwLCBiYXNlKSB7XG4gICAgdmFyIGNtcCwgZSwgaSwgaywgbG9nQmFzZSwgbW9yZSwgcHJvZCwgcHJvZEwsIHEsIHFkLCByZW0sIHJlbUwsIHJlbTAsIHNkLCB0LCB4aSwgeEwsIHlkMCwgeUwsIHl6LCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc2lnbjIgPSB4LnMgPT0geS5zID8gMSA6IC0xLCB4ZCA9IHguZCwgeWQgPSB5LmQ7XG4gICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xuICAgICAgcmV0dXJuIG5ldyBDdG9yKCF4LnMgfHwgIXkucyB8fCAoeGQgPyB5ZCAmJiB4ZFswXSA9PSB5ZFswXSA6ICF5ZCkgPyBOYU4gOiB4ZCAmJiB4ZFswXSA9PSAwIHx8ICF5ZCA/IHNpZ24yICogMCA6IHNpZ24yIC8gMCk7XG4gICAgfVxuICAgIGlmIChiYXNlKSB7XG4gICAgICBsb2dCYXNlID0gMTtcbiAgICAgIGUgPSB4LmUgLSB5LmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBCQVNFO1xuICAgICAgbG9nQmFzZSA9IExPR19CQVNFO1xuICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBsb2dCYXNlKSAtIG1hdGhmbG9vcih5LmUgLyBsb2dCYXNlKTtcbiAgICB9XG4gICAgeUwgPSB5ZC5sZW5ndGg7XG4gICAgeEwgPSB4ZC5sZW5ndGg7XG4gICAgcSA9IG5ldyBDdG9yKHNpZ24yKTtcbiAgICBxZCA9IHEuZCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IHlkW2ldID09ICh4ZFtpXSB8fCAwKTsgaSsrKVxuICAgICAgO1xuICAgIGlmICh5ZFtpXSA+ICh4ZFtpXSB8fCAwKSlcbiAgICAgIGUtLTtcbiAgICBpZiAocHIgPT0gbnVsbCkge1xuICAgICAgc2QgPSBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIH0gZWxzZSBpZiAoZHApIHtcbiAgICAgIHNkID0gcHIgKyAoeC5lIC0geS5lKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNkID0gcHI7XG4gICAgfVxuICAgIGlmIChzZCA8IDApIHtcbiAgICAgIHFkLnB1c2goMSk7XG4gICAgICBtb3JlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2QgPSBzZCAvIGxvZ0Jhc2UgKyAyIHwgMDtcbiAgICAgIGkgPSAwO1xuICAgICAgaWYgKHlMID09IDEpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIHlkID0geWRbMF07XG4gICAgICAgIHNkKys7XG4gICAgICAgIGZvciAoOyAoaSA8IHhMIHx8IGspICYmIHNkLS07IGkrKykge1xuICAgICAgICAgIHQgPSBrICogYmFzZSArICh4ZFtpXSB8fCAwKTtcbiAgICAgICAgICBxZFtpXSA9IHQgLyB5ZCB8IDA7XG4gICAgICAgICAgayA9IHQgJSB5ZCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbW9yZSA9IGsgfHwgaSA8IHhMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9IGJhc2UgLyAoeWRbMF0gKyAxKSB8IDA7XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgIHlkID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcbiAgICAgICAgICB4ZCA9IG11bHRpcGx5SW50ZWdlcih4ZCwgaywgYmFzZSk7XG4gICAgICAgICAgeUwgPSB5ZC5sZW5ndGg7XG4gICAgICAgICAgeEwgPSB4ZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgeGkgPSB5TDtcbiAgICAgICAgcmVtID0geGQuc2xpY2UoMCwgeUwpO1xuICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgKVxuICAgICAgICAgIHJlbVtyZW1MKytdID0gMDtcbiAgICAgICAgeXogPSB5ZC5zbGljZSgpO1xuICAgICAgICB5ei51bnNoaWZ0KDApO1xuICAgICAgICB5ZDAgPSB5ZFswXTtcbiAgICAgICAgaWYgKHlkWzFdID49IGJhc2UgLyAyKVxuICAgICAgICAgICsreWQwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XG4gICAgICAgICAgICBpZiAoeUwgIT0gcmVtTClcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcbiAgICAgICAgICAgIGsgPSByZW0wIC8geWQwIHwgMDtcbiAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICBpZiAoayA+PSBiYXNlKVxuICAgICAgICAgICAgICAgIGsgPSBiYXNlIC0gMTtcbiAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpO1xuICAgICAgICAgICAgICBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWQsIHByb2RMLCBiYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGsgPT0gMClcbiAgICAgICAgICAgICAgICBjbXAgPSBrID0gMTtcbiAgICAgICAgICAgICAgcHJvZCA9IHlkLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTClcbiAgICAgICAgICAgICAgcHJvZC51bnNoaWZ0KDApO1xuICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWQsIHJlbSwgeUwsIHJlbUwpO1xuICAgICAgICAgICAgICBpZiAoY21wIDwgMSkge1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWQsIHJlbUwsIGJhc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgcmVtID0gWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxZFtpKytdID0gaztcbiAgICAgICAgICBpZiAoY21wICYmIHJlbVswXSkge1xuICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4ZFt4aV0gfHwgMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtID0gW3hkW3hpXV07XG4gICAgICAgICAgICByZW1MID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9PSB2b2lkIDApICYmIHNkLS0pO1xuICAgICAgICBtb3JlID0gcmVtWzBdICE9PSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAoIXFkWzBdKVxuICAgICAgICBxZC5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAobG9nQmFzZSA9PSAxKSB7XG4gICAgICBxLmUgPSBlO1xuICAgICAgaW5leGFjdCA9IG1vcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDEsIGsgPSBxZFswXTsgayA+PSAxMDsgayAvPSAxMClcbiAgICAgICAgaSsrO1xuICAgICAgcS5lID0gaSArIGUgKiBsb2dCYXNlIC0gMTtcbiAgICAgIGZpbmFsaXNlKHEsIGRwID8gcHIgKyBxLmUgKyAxIDogcHIsIHJtLCBtb3JlKTtcbiAgICB9XG4gICAgcmV0dXJuIHE7XG4gIH07XG59KCk7XG5mdW5jdGlvbiBmaW5hbGlzZSh4LCBzZCwgcm0sIGlzVHJ1bmNhdGVkKSB7XG4gIHZhciBkaWdpdHMsIGksIGosIGssIHJkLCByb3VuZFVwLCB3LCB4ZCwgeGRpLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgb3V0OlxuICAgIGlmIChzZCAhPSBudWxsKSB7XG4gICAgICB4ZCA9IHguZDtcbiAgICAgIGlmICgheGQpXG4gICAgICAgIHJldHVybiB4O1xuICAgICAgZm9yIChkaWdpdHMgPSAxLCBrID0geGRbMF07IGsgPj0gMTA7IGsgLz0gMTApXG4gICAgICAgIGRpZ2l0cysrO1xuICAgICAgaSA9IHNkIC0gZGlnaXRzO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgICAgIGogPSBzZDtcbiAgICAgICAgdyA9IHhkW3hkaSA9IDBdO1xuICAgICAgICByZCA9IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcbiAgICAgICAgayA9IHhkLmxlbmd0aDtcbiAgICAgICAgaWYgKHhkaSA+PSBrKSB7XG4gICAgICAgICAgaWYgKGlzVHJ1bmNhdGVkKSB7XG4gICAgICAgICAgICBmb3IgKDsgaysrIDw9IHhkaTsgKVxuICAgICAgICAgICAgICB4ZC5wdXNoKDApO1xuICAgICAgICAgICAgdyA9IHJkID0gMDtcbiAgICAgICAgICAgIGRpZ2l0cyA9IDE7XG4gICAgICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyA9IGsgPSB4ZFt4ZGldO1xuICAgICAgICAgIGZvciAoZGlnaXRzID0gMTsgayA+PSAxMDsgayAvPSAxMClcbiAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XG4gICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGRpZ2l0cztcbiAgICAgICAgICByZCA9IGogPCAwID8gMCA6IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzVHJ1bmNhdGVkID0gaXNUcnVuY2F0ZWQgfHwgc2QgPCAwIHx8IHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xuICAgICAgcm91bmRVcCA9IHJtIDwgNCA/IChyZCB8fCBpc1RydW5jYXRlZCkgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgaXNUcnVuY2F0ZWQgfHwgcm0gPT0gNiAmJiAoaSA+IDAgPyBqID4gMCA/IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSA6IDAgOiB4ZFt4ZGkgLSAxXSkgJSAxMCAmIDEgfHwgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xuICAgICAgaWYgKHNkIDwgMSB8fCAheGRbMF0pIHtcbiAgICAgICAgeGQubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHJvdW5kVXApIHtcbiAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xuICAgICAgICAgIHhkWzBdID0gbWF0aHBvdygxMCwgKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRSk7XG4gICAgICAgICAgeC5lID0gLXNkIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGRbMF0gPSB4LmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICB4ZC5sZW5ndGggPSB4ZGk7XG4gICAgICAgIGsgPSAxO1xuICAgICAgICB4ZGktLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhkLmxlbmd0aCA9IHhkaSArIDE7XG4gICAgICAgIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xuICAgICAgICB4ZFt4ZGldID0gaiA+IDAgPyAodyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopICUgbWF0aHBvdygxMCwgaikgfCAwKSAqIGsgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKHJvdW5kVXApIHtcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgaWYgKHhkaSA9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGRbMF07IGogPj0gMTA7IGogLz0gMTApXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGogPSB4ZFswXSArPSBrO1xuICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMClcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgaWYgKGkgIT0gaykge1xuICAgICAgICAgICAgICB4LmUrKztcbiAgICAgICAgICAgICAgaWYgKHhkWzBdID09IEJBU0UpXG4gICAgICAgICAgICAgICAgeGRbMF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhkW3hkaV0gKz0gaztcbiAgICAgICAgICAgIGlmICh4ZFt4ZGldICE9IEJBU0UpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgeGRbeGRpLS1dID0gMDtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0geGQubGVuZ3RoOyB4ZFstLWldID09PSAwOyApXG4gICAgICAgIHhkLnBvcCgpO1xuICAgIH1cbiAgaWYgKGV4dGVybmFsKSB7XG4gICAgaWYgKHguZSA+IEN0b3IubWF4RSkge1xuICAgICAgeC5kID0gbnVsbDtcbiAgICAgIHguZSA9IE5hTjtcbiAgICB9IGVsc2UgaWYgKHguZSA8IEN0b3IubWluRSkge1xuICAgICAgeC5lID0gMDtcbiAgICAgIHguZCA9IFswXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5fX25hbWUoZmluYWxpc2UsIFwiZmluYWxpc2VcIik7XG5mdW5jdGlvbiBmaW5pdGVUb1N0cmluZyh4LCBpc0V4cCwgc2QpIHtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xuICB2YXIgaywgZSA9IHguZSwgc3RyID0gZGlnaXRzVG9TdHJpbmcoeC5kKSwgbGVuID0gc3RyLmxlbmd0aDtcbiAgaWYgKGlzRXhwKSB7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpICsgZ2V0WmVyb1N0cmluZyhrKTtcbiAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKTtcbiAgICB9XG4gICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyBcImVcIiA6IFwiZStcIikgKyB4LmU7XG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICBzdHIgPSBcIjAuXCIgKyBnZXRaZXJvU3RyaW5nKC1lIC0gMSkgKyBzdHI7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMClcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XG4gICAgc3RyICs9IGdldFplcm9TdHJpbmcoZSArIDEgLSBsZW4pO1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gZSAtIDEpID4gMClcbiAgICAgIHN0ciA9IHN0ciArIFwiLlwiICsgZ2V0WmVyb1N0cmluZyhrKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoKGsgPSBlICsgMSkgPCBsZW4pXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgaykgKyBcIi5cIiArIHN0ci5zbGljZShrKTtcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XG4gICAgICBpZiAoZSArIDEgPT09IGxlbilcbiAgICAgICAgc3RyICs9IFwiLlwiO1xuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5fX25hbWUoZmluaXRlVG9TdHJpbmcsIFwiZmluaXRlVG9TdHJpbmdcIik7XG5mdW5jdGlvbiBnZXRCYXNlMTBFeHBvbmVudChkaWdpdHMsIGUpIHtcbiAgdmFyIHcgPSBkaWdpdHNbMF07XG4gIGZvciAoZSAqPSBMT0dfQkFTRTsgdyA+PSAxMDsgdyAvPSAxMClcbiAgICBlKys7XG4gIHJldHVybiBlO1xufVxuX19uYW1lKGdldEJhc2UxMEV4cG9uZW50LCBcImdldEJhc2UxMEV4cG9uZW50XCIpO1xuZnVuY3Rpb24gZ2V0TG4xMChDdG9yLCBzZCwgcHIpIHtcbiAgaWYgKHNkID4gTE4xMF9QUkVDSVNJT04pIHtcbiAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgaWYgKHByKVxuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcbiAgfVxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoTE4xMCksIHNkLCAxLCB0cnVlKTtcbn1cbl9fbmFtZShnZXRMbjEwLCBcImdldExuMTBcIik7XG5mdW5jdGlvbiBnZXRQaShDdG9yLCBzZCwgcm0pIHtcbiAgaWYgKHNkID4gUElfUFJFQ0lTSU9OKVxuICAgIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoUEkpLCBzZCwgcm0sIHRydWUpO1xufVxuX19uYW1lKGdldFBpLCBcImdldFBpXCIpO1xuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRpZ2l0cykge1xuICB2YXIgdyA9IGRpZ2l0cy5sZW5ndGggLSAxLCBsZW4gPSB3ICogTE9HX0JBU0UgKyAxO1xuICB3ID0gZGlnaXRzW3ddO1xuICBpZiAodykge1xuICAgIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMClcbiAgICAgIGxlbi0tO1xuICAgIGZvciAodyA9IGRpZ2l0c1swXTsgdyA+PSAxMDsgdyAvPSAxMClcbiAgICAgIGxlbisrO1xuICB9XG4gIHJldHVybiBsZW47XG59XG5fX25hbWUoZ2V0UHJlY2lzaW9uLCBcImdldFByZWNpc2lvblwiKTtcbmZ1bmN0aW9uIGdldFplcm9TdHJpbmcoaykge1xuICB2YXIgenMgPSBcIlwiO1xuICBmb3IgKDsgay0tOyApXG4gICAgenMgKz0gXCIwXCI7XG4gIHJldHVybiB6cztcbn1cbl9fbmFtZShnZXRaZXJvU3RyaW5nLCBcImdldFplcm9TdHJpbmdcIik7XG5mdW5jdGlvbiBpbnRQb3coQ3RvciwgeCwgbiwgcHIpIHtcbiAgdmFyIGlzVHJ1bmNhdGVkLCByID0gbmV3IEN0b3IoMSksIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSArIDQpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBmb3IgKDsgOyApIHtcbiAgICBpZiAobiAlIDIpIHtcbiAgICAgIHIgPSByLnRpbWVzKHgpO1xuICAgICAgaWYgKHRydW5jYXRlKHIuZCwgaykpXG4gICAgICAgIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbiA9IG1hdGhmbG9vcihuIC8gMik7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIG4gPSByLmQubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpc1RydW5jYXRlZCAmJiByLmRbbl0gPT09IDApXG4gICAgICAgICsrci5kW25dO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHggPSB4LnRpbWVzKHgpO1xuICAgIHRydW5jYXRlKHguZCwgayk7XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gcjtcbn1cbl9fbmFtZShpbnRQb3csIFwiaW50UG93XCIpO1xuZnVuY3Rpb24gaXNPZGQobikge1xuICByZXR1cm4gbi5kW24uZC5sZW5ndGggLSAxXSAmIDE7XG59XG5fX25hbWUoaXNPZGQsIFwiaXNPZGRcIik7XG5mdW5jdGlvbiBtYXhPck1pbihDdG9yLCBhcmdzLCBsdGd0KSB7XG4gIHZhciB5LCB4ID0gbmV3IEN0b3IoYXJnc1swXSksIGkgPSAwO1xuICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7ICkge1xuICAgIHkgPSBuZXcgQ3RvcihhcmdzW2ldKTtcbiAgICBpZiAoIXkucykge1xuICAgICAgeCA9IHk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHhbbHRndF0oeSkpIHtcbiAgICAgIHggPSB5O1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn1cbl9fbmFtZShtYXhPck1pbiwgXCJtYXhPck1pblwiKTtcbmZ1bmN0aW9uIG5hdHVyYWxFeHBvbmVudGlhbCh4LCBzZCkge1xuICB2YXIgZGVub21pbmF0b3IsIGd1YXJkLCBqLCBwb3cyLCBzdW0yLCB0LCB3cHIsIHJlcCA9IDAsIGkgPSAwLCBrID0gMCwgQ3RvciA9IHguY29uc3RydWN0b3IsIHJtID0gQ3Rvci5yb3VuZGluZywgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgaWYgKCF4LmQgfHwgIXguZFswXSB8fCB4LmUgPiAxNykge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4LmQgPyAheC5kWzBdID8gMSA6IHgucyA8IDAgPyAwIDogMSAvIDAgOiB4LnMgPyB4LnMgPCAwID8gMCA6IHggOiAwIC8gMCk7XG4gIH1cbiAgaWYgKHNkID09IG51bGwpIHtcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgIHdwciA9IHByO1xuICB9IGVsc2Uge1xuICAgIHdwciA9IHNkO1xuICB9XG4gIHQgPSBuZXcgQ3RvcigwLjAzMTI1KTtcbiAgd2hpbGUgKHguZSA+IC0yKSB7XG4gICAgeCA9IHgudGltZXModCk7XG4gICAgayArPSA1O1xuICB9XG4gIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XG4gIHdwciArPSBndWFyZDtcbiAgZGVub21pbmF0b3IgPSBwb3cyID0gc3VtMiA9IG5ldyBDdG9yKDEpO1xuICBDdG9yLnByZWNpc2lvbiA9IHdwcjtcbiAgZm9yICg7IDsgKSB7XG4gICAgcG93MiA9IGZpbmFsaXNlKHBvdzIudGltZXMoeCksIHdwciwgMSk7XG4gICAgZGVub21pbmF0b3IgPSBkZW5vbWluYXRvci50aW1lcygrK2kpO1xuICAgIHQgPSBzdW0yLnBsdXMoZGl2aWRlKHBvdzIsIGRlbm9taW5hdG9yLCB3cHIsIDEpKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCB3cHIpID09PSBkaWdpdHNUb1N0cmluZyhzdW0yLmQpLnNsaWNlKDAsIHdwcikpIHtcbiAgICAgIGogPSBrO1xuICAgICAgd2hpbGUgKGotLSlcbiAgICAgICAgc3VtMiA9IGZpbmFsaXNlKHN1bTIudGltZXMoc3VtMiksIHdwciwgMSk7XG4gICAgICBpZiAoc2QgPT0gbnVsbCkge1xuICAgICAgICBpZiAocmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKHN1bTIuZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XG4gICAgICAgICAgZGVub21pbmF0b3IgPSBwb3cyID0gdCA9IG5ldyBDdG9yKDEpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHJlcCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0yLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgcmV0dXJuIHN1bTI7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bTIgPSB0O1xuICB9XG59XG5fX25hbWUobmF0dXJhbEV4cG9uZW50aWFsLCBcIm5hdHVyYWxFeHBvbmVudGlhbFwiKTtcbmZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcbiAgdmFyIGMsIGMwLCBkZW5vbWluYXRvciwgZSwgbnVtZXJhdG9yLCByZXAsIHN1bTIsIHQsIHdwciwgeDEsIHgyLCBuID0gMSwgZ3VhcmQgPSAxMCwgeCA9IHksIHhkID0geC5kLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgcm0gPSBDdG9yLnJvdW5kaW5nLCBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBpZiAoeC5zIDwgMCB8fCAheGQgfHwgIXhkWzBdIHx8ICF4LmUgJiYgeGRbMF0gPT0gMSAmJiB4ZC5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4ZCAmJiAheGRbMF0gPyAtMSAvIDAgOiB4LnMgIT0gMSA/IE5hTiA6IHhkID8gMCA6IHgpO1xuICB9XG4gIGlmIChzZCA9PSBudWxsKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB3cHIgPSBwcjtcbiAgfSBlbHNlIHtcbiAgICB3cHIgPSBzZDtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcbiAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcbiAgYzAgPSBjLmNoYXJBdCgwKTtcbiAgaWYgKE1hdGguYWJzKGUgPSB4LmUpIDwgMTVlMTQpIHtcbiAgICB3aGlsZSAoYzAgPCA3ICYmIGMwICE9IDEgfHwgYzAgPT0gMSAmJiBjLmNoYXJBdCgxKSA+IDMpIHtcbiAgICAgIHggPSB4LnRpbWVzKHkpO1xuICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XG4gICAgICBjMCA9IGMuY2hhckF0KDApO1xuICAgICAgbisrO1xuICAgIH1cbiAgICBlID0geC5lO1xuICAgIGlmIChjMCA+IDEpIHtcbiAgICAgIHggPSBuZXcgQ3RvcihcIjAuXCIgKyBjKTtcbiAgICAgIGUrKztcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IG5ldyBDdG9yKGMwICsgXCIuXCIgKyBjLnNsaWNlKDEpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdCA9IGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyBcIlwiKTtcbiAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArIFwiLlwiICsgYy5zbGljZSgxKSksIHdwciAtIGd1YXJkKS5wbHVzKHQpO1xuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgcmV0dXJuIHNkID09IG51bGwgPyBmaW5hbGlzZSh4LCBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSkgOiB4O1xuICB9XG4gIHgxID0geDtcbiAgc3VtMiA9IG51bWVyYXRvciA9IHggPSBkaXZpZGUoeC5taW51cygxKSwgeC5wbHVzKDEpLCB3cHIsIDEpO1xuICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XG4gIGRlbm9taW5hdG9yID0gMztcbiAgZm9yICg7IDsgKSB7XG4gICAgbnVtZXJhdG9yID0gZmluYWxpc2UobnVtZXJhdG9yLnRpbWVzKHgyKSwgd3ByLCAxKTtcbiAgICB0ID0gc3VtMi5wbHVzKGRpdmlkZShudW1lcmF0b3IsIG5ldyBDdG9yKGRlbm9taW5hdG9yKSwgd3ByLCAxKSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtMi5kKS5zbGljZSgwLCB3cHIpKSB7XG4gICAgICBzdW0yID0gc3VtMi50aW1lcygyKTtcbiAgICAgIGlmIChlICE9PSAwKVxuICAgICAgICBzdW0yID0gc3VtMi5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyBcIlwiKSk7XG4gICAgICBzdW0yID0gZGl2aWRlKHN1bTIsIG5ldyBDdG9yKG4pLCB3cHIsIDEpO1xuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtMi5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcbiAgICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcbiAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcbiAgICAgICAgICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XG4gICAgICAgICAgZGVub21pbmF0b3IgPSByZXAgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0yLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgcmV0dXJuIHN1bTI7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bTIgPSB0O1xuICAgIGRlbm9taW5hdG9yICs9IDI7XG4gIH1cbn1cbl9fbmFtZShuYXR1cmFsTG9nYXJpdGhtLCBcIm5hdHVyYWxMb2dhcml0aG1cIik7XG5mdW5jdGlvbiBub25GaW5pdGVUb1N0cmluZyh4KSB7XG4gIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XG59XG5fX25hbWUobm9uRmluaXRlVG9TdHJpbmcsIFwibm9uRmluaXRlVG9TdHJpbmdcIik7XG5mdW5jdGlvbiBwYXJzZURlY2ltYWwoeCwgc3RyKSB7XG4gIHZhciBlLCBpLCBsZW47XG4gIGlmICgoZSA9IHN0ci5pbmRleE9mKFwiLlwiKSkgPiAtMSlcbiAgICBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xuICAgIGlmIChlIDwgMClcbiAgICAgIGUgPSBpO1xuICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xuICAgIGUgPSBzdHIubGVuZ3RoO1xuICB9XG4gIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKVxuICAgIDtcbiAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdChsZW4gLSAxKSA9PT0gNDg7IC0tbGVuKVxuICAgIDtcbiAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XG4gIGlmIChzdHIpIHtcbiAgICBsZW4gLT0gaTtcbiAgICB4LmUgPSBlID0gZSAtIGkgLSAxO1xuICAgIHguZCA9IFtdO1xuICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XG4gICAgaWYgKGUgPCAwKVxuICAgICAgaSArPSBMT0dfQkFTRTtcbiAgICBpZiAoaSA8IGxlbikge1xuICAgICAgaWYgKGkpXG4gICAgICAgIHguZC5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xuICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47IClcbiAgICAgICAgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XG4gICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpIC09IGxlbjtcbiAgICB9XG4gICAgZm9yICg7IGktLTsgKVxuICAgICAgc3RyICs9IFwiMFwiO1xuICAgIHguZC5wdXNoKCtzdHIpO1xuICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xuICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICB4LmUgPSBOYU47XG4gICAgICB9IGVsc2UgaWYgKHguZSA8IHguY29uc3RydWN0b3IubWluRSkge1xuICAgICAgICB4LmUgPSAwO1xuICAgICAgICB4LmQgPSBbMF07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHguZSA9IDA7XG4gICAgeC5kID0gWzBdO1xuICB9XG4gIHJldHVybiB4O1xufVxuX19uYW1lKHBhcnNlRGVjaW1hbCwgXCJwYXJzZURlY2ltYWxcIik7XG5mdW5jdGlvbiBwYXJzZU90aGVyKHgsIHN0cikge1xuICB2YXIgYmFzZSwgQ3RvciwgZGl2aXNvciwgaSwgaXNGbG9hdCwgbGVuLCBwLCB4ZCwgeGU7XG4gIGlmIChzdHIuaW5kZXhPZihcIl9cIikgPiAtMSkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csIFwiJDFcIik7XG4gICAgaWYgKGlzRGVjaW1hbC50ZXN0KHN0cikpXG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHN0cik7XG4gIH0gZWxzZSBpZiAoc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIk5hTlwiKSB7XG4gICAgaWYgKCErc3RyKVxuICAgICAgeC5zID0gTmFOO1xuICAgIHguZSA9IE5hTjtcbiAgICB4LmQgPSBudWxsO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGlmIChpc0hleC50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gMTY7XG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoaXNCaW5hcnkudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDI7XG4gIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBzdHIpO1xuICB9XG4gIGkgPSBzdHIuc2VhcmNoKC9wL2kpO1xuICBpZiAoaSA+IDApIHtcbiAgICBwID0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMik7XG4gIH1cbiAgaSA9IHN0ci5pbmRleE9mKFwiLlwiKTtcbiAgaXNGbG9hdCA9IGkgPj0gMDtcbiAgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChpc0Zsb2F0KSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaSA9IGxlbiAtIGk7XG4gICAgZGl2aXNvciA9IGludFBvdyhDdG9yLCBuZXcgQ3RvcihiYXNlKSwgaSwgaSAqIDIpO1xuICB9XG4gIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBCQVNFKTtcbiAgeGUgPSB4ZC5sZW5ndGggLSAxO1xuICBmb3IgKGkgPSB4ZTsgeGRbaV0gPT09IDA7IC0taSlcbiAgICB4ZC5wb3AoKTtcbiAgaWYgKGkgPCAwKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4LnMgKiAwKTtcbiAgeC5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIHhlKTtcbiAgeC5kID0geGQ7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGlmIChpc0Zsb2F0KVxuICAgIHggPSBkaXZpZGUoeCwgZGl2aXNvciwgbGVuICogNCk7XG4gIGlmIChwKVxuICAgIHggPSB4LnRpbWVzKE1hdGguYWJzKHApIDwgNTQgPyBtYXRocG93KDIsIHApIDogRGVjaW1hbC5wb3coMiwgcCkpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiB4O1xufVxuX19uYW1lKHBhcnNlT3RoZXIsIFwicGFyc2VPdGhlclwiKTtcbmZ1bmN0aW9uIHNpbmUoQ3RvciwgeCkge1xuICB2YXIgaywgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMpIHtcbiAgICByZXR1cm4geC5pc1plcm8oKSA/IHggOiB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XG4gIH1cbiAgayA9IDEuNCAqIE1hdGguc3FydChsZW4pO1xuICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcbiAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xuICB2YXIgc2luMl94LCBkNSA9IG5ldyBDdG9yKDUpLCBkMTYgPSBuZXcgQ3RvcigxNiksIGQyMCA9IG5ldyBDdG9yKDIwKTtcbiAgZm9yICg7IGstLTsgKSB7XG4gICAgc2luMl94ID0geC50aW1lcyh4KTtcbiAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbjJfeC50aW1lcyhkMTYudGltZXMoc2luMl94KS5taW51cyhkMjApKSkpO1xuICB9XG4gIHJldHVybiB4O1xufVxuX19uYW1lKHNpbmUsIFwic2luZVwiKTtcbmZ1bmN0aW9uIHRheWxvclNlcmllcyhDdG9yLCBuLCB4LCB5LCBpc0h5cGVyYm9saWMpIHtcbiAgdmFyIGosIHQsIHUsIHgyLCBpID0gMSwgcHIgPSBDdG9yLnByZWNpc2lvbiwgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeDIgPSB4LnRpbWVzKHgpO1xuICB1ID0gbmV3IEN0b3IoeSk7XG4gIGZvciAoOyA7ICkge1xuICAgIHQgPSBkaXZpZGUodS50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcbiAgICB1ID0gaXNIeXBlcmJvbGljID8geS5wbHVzKHQpIDogeS5taW51cyh0KTtcbiAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XG4gICAgdCA9IHUucGx1cyh5KTtcbiAgICBpZiAodC5kW2tdICE9PSB2b2lkIDApIHtcbiAgICAgIGZvciAoaiA9IGs7IHQuZFtqXSA9PT0gdS5kW2pdICYmIGotLTsgKVxuICAgICAgICA7XG4gICAgICBpZiAoaiA9PSAtMSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGogPSB1O1xuICAgIHUgPSB5O1xuICAgIHkgPSB0O1xuICAgIHQgPSBqO1xuICAgIGkrKztcbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHQuZC5sZW5ndGggPSBrICsgMTtcbiAgcmV0dXJuIHQ7XG59XG5fX25hbWUodGF5bG9yU2VyaWVzLCBcInRheWxvclNlcmllc1wiKTtcbmZ1bmN0aW9uIHRpbnlQb3coYiwgZSkge1xuICB2YXIgbiA9IGI7XG4gIHdoaWxlICgtLWUpXG4gICAgbiAqPSBiO1xuICByZXR1cm4gbjtcbn1cbl9fbmFtZSh0aW55UG93LCBcInRpbnlQb3dcIik7XG5mdW5jdGlvbiB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpIHtcbiAgdmFyIHQsIGlzTmVnID0geC5zIDwgMCwgcGkgPSBnZXRQaShDdG9yLCBDdG9yLnByZWNpc2lvbiwgMSksIGhhbGZQaSA9IHBpLnRpbWVzKDAuNSk7XG4gIHggPSB4LmFicygpO1xuICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgIHF1YWRyYW50ID0gaXNOZWcgPyA0IDogMTtcbiAgICByZXR1cm4geDtcbiAgfVxuICB0ID0geC5kaXZUb0ludChwaSk7XG4gIGlmICh0LmlzWmVybygpKSB7XG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDMgOiAyO1xuICB9IGVsc2Uge1xuICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcbiAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IGlzTmVnID8gMiA6IDMgOiBpc05lZyA/IDQgOiAxO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyBpc05lZyA/IDEgOiA0IDogaXNOZWcgPyAzIDogMjtcbiAgfVxuICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XG59XG5fX25hbWUodG9MZXNzVGhhbkhhbGZQaSwgXCJ0b0xlc3NUaGFuSGFsZlBpXCIpO1xuZnVuY3Rpb24gdG9TdHJpbmdCaW5hcnkoeCwgYmFzZU91dCwgc2QsIHJtKSB7XG4gIHZhciBiYXNlLCBlLCBpLCBrLCBsZW4sIHJvdW5kVXAsIHN0ciwgeGQsIHksIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XG4gIGlmIChpc0V4cCkge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2VcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICB9IGVsc2Uge1xuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9XG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XG4gICAgc3RyID0gbm9uRmluaXRlVG9TdHJpbmcoeCk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XG4gICAgaSA9IHN0ci5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaXNFeHApIHtcbiAgICAgIGJhc2UgPSAyO1xuICAgICAgaWYgKGJhc2VPdXQgPT0gMTYpIHtcbiAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xuICAgICAgfSBlbHNlIGlmIChiYXNlT3V0ID09IDgpIHtcbiAgICAgICAgc2QgPSBzZCAqIDMgLSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gYmFzZU91dDtcbiAgICB9XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgICAgeSA9IG5ldyBDdG9yKDEpO1xuICAgICAgeS5lID0gc3RyLmxlbmd0aCAtIGk7XG4gICAgICB5LmQgPSBjb252ZXJ0QmFzZShmaW5pdGVUb1N0cmluZyh5KSwgMTAsIGJhc2UpO1xuICAgICAgeS5lID0geS5kLmxlbmd0aDtcbiAgICB9XG4gICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIDEwLCBiYXNlKTtcbiAgICBlID0gbGVuID0geGQubGVuZ3RoO1xuICAgIGZvciAoOyB4ZFstLWxlbl0gPT0gMDsgKVxuICAgICAgeGQucG9wKCk7XG4gICAgaWYgKCF4ZFswXSkge1xuICAgICAgc3RyID0gaXNFeHAgPyBcIjBwKzBcIiA6IFwiMFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgZS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xuICAgICAgICB4LmQgPSB4ZDtcbiAgICAgICAgeC5lID0gZTtcbiAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xuICAgICAgICB4ZCA9IHguZDtcbiAgICAgICAgZSA9IHguZTtcbiAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XG4gICAgICB9XG4gICAgICBpID0geGRbc2RdO1xuICAgICAgayA9IGJhc2UgLyAyO1xuICAgICAgcm91bmRVcCA9IHJvdW5kVXAgfHwgeGRbc2QgKyAxXSAhPT0gdm9pZCAwO1xuICAgICAgcm91bmRVcCA9IHJtIDwgNCA/IChpICE9PSB2b2lkIDAgfHwgcm91bmRVcCkgJiYgKHJtID09PSAwIHx8IHJtID09PSAoeC5zIDwgMCA/IDMgOiAyKSkgOiBpID4gayB8fCBpID09PSBrICYmIChybSA9PT0gNCB8fCByb3VuZFVwIHx8IHJtID09PSA2ICYmIHhkW3NkIC0gMV0gJiAxIHx8IHJtID09PSAoeC5zIDwgMCA/IDggOiA3KSk7XG4gICAgICB4ZC5sZW5ndGggPSBzZDtcbiAgICAgIGlmIChyb3VuZFVwKSB7XG4gICAgICAgIGZvciAoOyArK3hkWy0tc2RdID4gYmFzZSAtIDE7ICkge1xuICAgICAgICAgIHhkW3NkXSA9IDA7XG4gICAgICAgICAgaWYgKCFzZCkge1xuICAgICAgICAgICAgKytlO1xuICAgICAgICAgICAgeGQudW5zaGlmdCgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKVxuICAgICAgICA7XG4gICAgICBmb3IgKGkgPSAwLCBzdHIgPSBcIlwiOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIHN0ciArPSBOVU1FUkFMUy5jaGFyQXQoeGRbaV0pO1xuICAgICAgaWYgKGlzRXhwKSB7XG4gICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYgfHwgYmFzZU91dCA9PSA4KSB7XG4gICAgICAgICAgICBpID0gYmFzZU91dCA9PSAxNiA/IDQgOiAzO1xuICAgICAgICAgICAgZm9yICgtLWxlbjsgbGVuICUgaTsgbGVuKyspXG4gICAgICAgICAgICAgIHN0ciArPSBcIjBcIjtcbiAgICAgICAgICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBiYXNlT3V0KTtcbiAgICAgICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBzdHIgPSBcIjEuXCI7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyICsgKGUgPCAwID8gXCJwXCIgOiBcInArXCIpICsgZTtcbiAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICAgICAgZm9yICg7ICsrZTsgKVxuICAgICAgICAgIHN0ciA9IFwiMFwiICsgc3RyO1xuICAgICAgICBzdHIgPSBcIjAuXCIgKyBzdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKytlID4gbGVuKVxuICAgICAgICAgIGZvciAoZSAtPSBsZW47IGUtLTsgKVxuICAgICAgICAgICAgc3RyICs9IFwiMFwiO1xuICAgICAgICBlbHNlIGlmIChlIDwgbGVuKVxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArIFwiLlwiICsgc3RyLnNsaWNlKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSAoYmFzZU91dCA9PSAxNiA/IFwiMHhcIiA6IGJhc2VPdXQgPT0gMiA/IFwiMGJcIiA6IGJhc2VPdXQgPT0gOCA/IFwiMG9cIiA6IFwiXCIpICsgc3RyO1xuICB9XG4gIHJldHVybiB4LnMgPCAwID8gXCItXCIgKyBzdHIgOiBzdHI7XG59XG5fX25hbWUodG9TdHJpbmdCaW5hcnksIFwidG9TdHJpbmdCaW5hcnlcIik7XG5mdW5jdGlvbiB0cnVuY2F0ZShhcnIsIGxlbikge1xuICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xuICAgIGFyci5sZW5ndGggPSBsZW47XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbl9fbmFtZSh0cnVuY2F0ZSwgXCJ0cnVuY2F0ZVwiKTtcbmZ1bmN0aW9uIGFicyh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hYnMoKTtcbn1cbl9fbmFtZShhYnMsIFwiYWJzXCIpO1xuZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hY29zKCk7XG59XG5fX25hbWUoYWNvcywgXCJhY29zXCIpO1xuZnVuY3Rpb24gYWNvc2goeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWNvc2goKTtcbn1cbl9fbmFtZShhY29zaCwgXCJhY29zaFwiKTtcbmZ1bmN0aW9uIGFkZCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5wbHVzKHkpO1xufVxuX19uYW1lKGFkZCwgXCJhZGRcIik7XG5mdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW4oKTtcbn1cbl9fbmFtZShhc2luLCBcImFzaW5cIik7XG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luaCgpO1xufVxuX19uYW1lKGFzaW5oLCBcImFzaW5oXCIpO1xuZnVuY3Rpb24gYXRhbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hdGFuKCk7XG59XG5fX25hbWUoYXRhbiwgXCJhdGFuXCIpO1xuZnVuY3Rpb24gYXRhbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcbn1cbl9fbmFtZShhdGFuaCwgXCJhdGFuaFwiKTtcbmZ1bmN0aW9uIGF0YW4yKHksIHgpIHtcbiAgeSA9IG5ldyB0aGlzKHkpO1xuICB4ID0gbmV3IHRoaXMoeCk7XG4gIHZhciByLCBwciA9IHRoaXMucHJlY2lzaW9uLCBybSA9IHRoaXMucm91bmRpbmcsIHdwciA9IHByICsgNDtcbiAgaWYgKCF5LnMgfHwgIXgucykge1xuICAgIHIgPSBuZXcgdGhpcyhOYU4pO1xuICB9IGVsc2UgaWYgKCF5LmQgJiYgIXguZCkge1xuICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKHgucyA+IDAgPyAwLjI1IDogMC43NSk7XG4gICAgci5zID0geS5zO1xuICB9IGVsc2UgaWYgKCF4LmQgfHwgeS5pc1plcm8oKSkge1xuICAgIHIgPSB4LnMgPCAwID8gZ2V0UGkodGhpcywgcHIsIHJtKSA6IG5ldyB0aGlzKDApO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICgheS5kIHx8IHguaXNaZXJvKCkpIHtcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcygwLjUpO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICh4LnMgPCAwKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSB3cHI7XG4gICAgdGhpcy5yb3VuZGluZyA9IDE7XG4gICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XG4gICAgeCA9IGdldFBpKHRoaXMsIHdwciwgMSk7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcjtcbiAgICB0aGlzLnJvdW5kaW5nID0gcm07XG4gICAgciA9IHkucyA8IDAgPyByLm1pbnVzKHgpIDogci5wbHVzKHgpO1xuICB9IGVsc2Uge1xuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xuICB9XG4gIHJldHVybiByO1xufVxuX19uYW1lKGF0YW4yLCBcImF0YW4yXCIpO1xuZnVuY3Rpb24gY2JydCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jYnJ0KCk7XG59XG5fX25hbWUoY2JydCwgXCJjYnJ0XCIpO1xuZnVuY3Rpb24gY2VpbCh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDIpO1xufVxuX19uYW1lKGNlaWwsIFwiY2VpbFwiKTtcbmZ1bmN0aW9uIGNsYW1wKHgsIG1pbjIsIG1heDIpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNsYW1wKG1pbjIsIG1heDIpO1xufVxuX19uYW1lKGNsYW1wLCBcImNsYW1wXCIpO1xuZnVuY3Rpb24gY29uZmlnKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKVxuICAgIHRocm93IEVycm9yKGRlY2ltYWxFcnJvciArIFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICB2YXIgaSwgcCwgdiwgdXNlRGVmYXVsdHMgPSBvYmouZGVmYXVsdHMgPT09IHRydWUsIHBzID0gW1xuICAgIFwicHJlY2lzaW9uXCIsXG4gICAgMSxcbiAgICBNQVhfRElHSVRTLFxuICAgIFwicm91bmRpbmdcIixcbiAgICAwLFxuICAgIDgsXG4gICAgXCJ0b0V4cE5lZ1wiLFxuICAgIC1FWFBfTElNSVQsXG4gICAgMCxcbiAgICBcInRvRXhwUG9zXCIsXG4gICAgMCxcbiAgICBFWFBfTElNSVQsXG4gICAgXCJtYXhFXCIsXG4gICAgMCxcbiAgICBFWFBfTElNSVQsXG4gICAgXCJtaW5FXCIsXG4gICAgLUVYUF9MSU1JVCxcbiAgICAwLFxuICAgIFwibW9kdWxvXCIsXG4gICAgMCxcbiAgICA5XG4gIF07XG4gIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGlmIChwID0gcHNbaV0sIHVzZURlZmF1bHRzKVxuICAgICAgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xuICAgIGlmICgodiA9IG9ialtwXSkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKG1hdGhmbG9vcih2KSA9PT0gdiAmJiB2ID49IHBzW2kgKyAxXSAmJiB2IDw9IHBzW2kgKyAyXSlcbiAgICAgICAgdGhpc1twXSA9IHY7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyBcIjogXCIgKyB2KTtcbiAgICB9XG4gIH1cbiAgaWYgKHAgPSBcImNyeXB0b1wiLCB1c2VEZWZhdWx0cylcbiAgICB0aGlzW3BdID0gREVGQVVMVFNbcF07XG4gIGlmICgodiA9IG9ialtwXSkgIT09IHZvaWQgMCkge1xuICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xuICAgICAgaWYgKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gXCJ1bmRlZmluZWRcIiAmJiBjcnlwdG8gJiYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgICAgIHRoaXNbcF0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgXCI6IFwiICsgdik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuX19uYW1lKGNvbmZpZywgXCJjb25maWdcIik7XG5mdW5jdGlvbiBjb3MoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zKCk7XG59XG5fX25hbWUoY29zLCBcImNvc1wiKTtcbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zaCgpO1xufVxuX19uYW1lKGNvc2gsIFwiY29zaFwiKTtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICB2YXIgaSwgcCwgcHM7XG4gIGZ1bmN0aW9uIERlY2ltYWwyKHYpIHtcbiAgICB2YXIgZSwgaTIsIHQsIHggPSB0aGlzO1xuICAgIGlmICghKHggaW5zdGFuY2VvZiBEZWNpbWFsMikpXG4gICAgICByZXR1cm4gbmV3IERlY2ltYWwyKHYpO1xuICAgIHguY29uc3RydWN0b3IgPSBEZWNpbWFsMjtcbiAgICBpZiAoaXNEZWNpbWFsSW5zdGFuY2UodikpIHtcbiAgICAgIHgucyA9IHYucztcbiAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICBpZiAoIXYuZCB8fCB2LmUgPiBEZWNpbWFsMi5tYXhFKSB7XG4gICAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgRGVjaW1hbDIubWluRSkge1xuICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHguZSA9IHYuZTtcbiAgICAgICAgICB4LmQgPSB2LmQuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICB4LmQgPSB2LmQgPyB2LmQuc2xpY2UoKSA6IHYuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdCA9IHR5cGVvZiB2O1xuICAgIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XG4gICAgICAgIHguZSA9IDA7XG4gICAgICAgIHguZCA9IFswXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgeC5zID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LnMgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XG4gICAgICAgIGZvciAoZSA9IDAsIGkyID0gdjsgaTIgPj0gMTA7IGkyIC89IDEwKVxuICAgICAgICAgIGUrKztcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgICAgaWYgKGUgPiBEZWNpbWFsMi5tYXhFKSB7XG4gICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSA8IERlY2ltYWwyLm1pbkUpIHtcbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgICB4LmQgPSBbdl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgeC5kID0gW3ZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodiAqIDAgIT09IDApIHtcbiAgICAgICAgaWYgKCF2KVxuICAgICAgICAgIHgucyA9IE5hTjtcbiAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB2KTtcbiAgICB9XG4gICAgaWYgKChpMiA9IHYuY2hhckNvZGVBdCgwKSkgPT09IDQ1KSB7XG4gICAgICB2ID0gdi5zbGljZSgxKTtcbiAgICAgIHgucyA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaTIgPT09IDQzKVxuICAgICAgICB2ID0gdi5zbGljZSgxKTtcbiAgICAgIHgucyA9IDE7XG4gICAgfVxuICAgIHJldHVybiBpc0RlY2ltYWwudGVzdCh2KSA/IHBhcnNlRGVjaW1hbCh4LCB2KSA6IHBhcnNlT3RoZXIoeCwgdik7XG4gIH1cbiAgX19uYW1lKERlY2ltYWwyLCBcIkRlY2ltYWxcIik7XG4gIERlY2ltYWwyLnByb3RvdHlwZSA9IFA7XG4gIERlY2ltYWwyLlJPVU5EX1VQID0gMDtcbiAgRGVjaW1hbDIuUk9VTkRfRE9XTiA9IDE7XG4gIERlY2ltYWwyLlJPVU5EX0NFSUwgPSAyO1xuICBEZWNpbWFsMi5ST1VORF9GTE9PUiA9IDM7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfVVAgPSA0O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0RPV04gPSA1O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0VWRU4gPSA2O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0NFSUwgPSA3O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0ZMT09SID0gODtcbiAgRGVjaW1hbDIuRVVDTElEID0gOTtcbiAgRGVjaW1hbDIuY29uZmlnID0gRGVjaW1hbDIuc2V0ID0gY29uZmlnO1xuICBEZWNpbWFsMi5jbG9uZSA9IGNsb25lO1xuICBEZWNpbWFsMi5pc0RlY2ltYWwgPSBpc0RlY2ltYWxJbnN0YW5jZTtcbiAgRGVjaW1hbDIuYWJzID0gYWJzO1xuICBEZWNpbWFsMi5hY29zID0gYWNvcztcbiAgRGVjaW1hbDIuYWNvc2ggPSBhY29zaDtcbiAgRGVjaW1hbDIuYWRkID0gYWRkO1xuICBEZWNpbWFsMi5hc2luID0gYXNpbjtcbiAgRGVjaW1hbDIuYXNpbmggPSBhc2luaDtcbiAgRGVjaW1hbDIuYXRhbiA9IGF0YW47XG4gIERlY2ltYWwyLmF0YW5oID0gYXRhbmg7XG4gIERlY2ltYWwyLmF0YW4yID0gYXRhbjI7XG4gIERlY2ltYWwyLmNicnQgPSBjYnJ0O1xuICBEZWNpbWFsMi5jZWlsID0gY2VpbDtcbiAgRGVjaW1hbDIuY2xhbXAgPSBjbGFtcDtcbiAgRGVjaW1hbDIuY29zID0gY29zO1xuICBEZWNpbWFsMi5jb3NoID0gY29zaDtcbiAgRGVjaW1hbDIuZGl2ID0gZGl2O1xuICBEZWNpbWFsMi5leHAgPSBleHA7XG4gIERlY2ltYWwyLmZsb29yID0gZmxvb3I7XG4gIERlY2ltYWwyLmh5cG90ID0gaHlwb3Q7XG4gIERlY2ltYWwyLmxuID0gbG47XG4gIERlY2ltYWwyLmxvZyA9IGxvZztcbiAgRGVjaW1hbDIubG9nMTAgPSBsb2cxMDtcbiAgRGVjaW1hbDIubG9nMiA9IGxvZzI7XG4gIERlY2ltYWwyLm1heCA9IG1heDtcbiAgRGVjaW1hbDIubWluID0gbWluO1xuICBEZWNpbWFsMi5tb2QgPSBtb2Q7XG4gIERlY2ltYWwyLm11bCA9IG11bDtcbiAgRGVjaW1hbDIucG93ID0gcG93O1xuICBEZWNpbWFsMi5yYW5kb20gPSByYW5kb207XG4gIERlY2ltYWwyLnJvdW5kID0gcm91bmQ7XG4gIERlY2ltYWwyLnNpZ24gPSBzaWduO1xuICBEZWNpbWFsMi5zaW4gPSBzaW47XG4gIERlY2ltYWwyLnNpbmggPSBzaW5oO1xuICBEZWNpbWFsMi5zcXJ0ID0gc3FydDtcbiAgRGVjaW1hbDIuc3ViID0gc3ViO1xuICBEZWNpbWFsMi5zdW0gPSBzdW07XG4gIERlY2ltYWwyLnRhbiA9IHRhbjtcbiAgRGVjaW1hbDIudGFuaCA9IHRhbmg7XG4gIERlY2ltYWwyLnRydW5jID0gdHJ1bmM7XG4gIGlmIChvYmogPT09IHZvaWQgMClcbiAgICBvYmogPSB7fTtcbiAgaWYgKG9iaikge1xuICAgIGlmIChvYmouZGVmYXVsdHMgIT09IHRydWUpIHtcbiAgICAgIHBzID0gW1wicHJlY2lzaW9uXCIsIFwicm91bmRpbmdcIiwgXCJ0b0V4cE5lZ1wiLCBcInRvRXhwUG9zXCIsIFwibWF4RVwiLCBcIm1pbkVcIiwgXCJtb2R1bG9cIiwgXCJjcnlwdG9cIl07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyApXG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KHAgPSBwc1tpKytdKSlcbiAgICAgICAgICBvYmpbcF0gPSB0aGlzW3BdO1xuICAgIH1cbiAgfVxuICBEZWNpbWFsMi5jb25maWcob2JqKTtcbiAgcmV0dXJuIERlY2ltYWwyO1xufVxuX19uYW1lKGNsb25lLCBcImNsb25lXCIpO1xuZnVuY3Rpb24gZGl2KHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcbn1cbl9fbmFtZShkaXYsIFwiZGl2XCIpO1xuZnVuY3Rpb24gZXhwKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmV4cCgpO1xufVxuX19uYW1lKGV4cCwgXCJleHBcIik7XG5mdW5jdGlvbiBmbG9vcih4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDMpO1xufVxuX19uYW1lKGZsb29yLCBcImZsb29yXCIpO1xuZnVuY3Rpb24gaHlwb3QoKSB7XG4gIHZhciBpLCBuLCB0ID0gbmV3IHRoaXMoMCk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyApIHtcbiAgICBuID0gbmV3IHRoaXMoYXJndW1lbnRzW2krK10pO1xuICAgIGlmICghbi5kKSB7XG4gICAgICBpZiAobi5zKSB7XG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKDEgLyAwKTtcbiAgICAgIH1cbiAgICAgIHQgPSBuO1xuICAgIH0gZWxzZSBpZiAodC5kKSB7XG4gICAgICB0ID0gdC5wbHVzKG4udGltZXMobikpO1xuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiB0LnNxcnQoKTtcbn1cbl9fbmFtZShoeXBvdCwgXCJoeXBvdFwiKTtcbmZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGVjaW1hbCB8fCBvYmogJiYgb2JqLnRvU3RyaW5nVGFnID09PSB0YWcgfHwgZmFsc2U7XG59XG5fX25hbWUoaXNEZWNpbWFsSW5zdGFuY2UsIFwiaXNEZWNpbWFsSW5zdGFuY2VcIik7XG5mdW5jdGlvbiBsbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sbigpO1xufVxuX19uYW1lKGxuLCBcImxuXCIpO1xuZnVuY3Rpb24gbG9nKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZyh5KTtcbn1cbl9fbmFtZShsb2csIFwibG9nXCIpO1xuZnVuY3Rpb24gbG9nMih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMik7XG59XG5fX25hbWUobG9nMiwgXCJsb2cyXCIpO1xuZnVuY3Rpb24gbG9nMTAoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDEwKTtcbn1cbl9fbmFtZShsb2cxMCwgXCJsb2cxMFwiKTtcbmZ1bmN0aW9uIG1heCgpIHtcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgXCJsdFwiKTtcbn1cbl9fbmFtZShtYXgsIFwibWF4XCIpO1xuZnVuY3Rpb24gbWluKCkge1xuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCBcImd0XCIpO1xufVxuX19uYW1lKG1pbiwgXCJtaW5cIik7XG5mdW5jdGlvbiBtb2QoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubW9kKHkpO1xufVxuX19uYW1lKG1vZCwgXCJtb2RcIik7XG5mdW5jdGlvbiBtdWwoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xufVxuX19uYW1lKG11bCwgXCJtdWxcIik7XG5mdW5jdGlvbiBwb3coeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkucG93KHkpO1xufVxuX19uYW1lKHBvdywgXCJwb3dcIik7XG5mdW5jdGlvbiByYW5kb20oc2QpIHtcbiAgdmFyIGQsIGUsIGssIG4sIGkgPSAwLCByID0gbmV3IHRoaXMoMSksIHJkID0gW107XG4gIGlmIChzZCA9PT0gdm9pZCAwKVxuICAgIHNkID0gdGhpcy5wcmVjaXNpb247XG4gIGVsc2VcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgayA9IE1hdGguY2VpbChzZCAvIExPR19CQVNFKTtcbiAgaWYgKCF0aGlzLmNyeXB0bykge1xuICAgIGZvciAoOyBpIDwgazsgKVxuICAgICAgcmRbaSsrXSA9IE1hdGgucmFuZG9tKCkgKiAxZTcgfCAwO1xuICB9IGVsc2UgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICBkID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoaykpO1xuICAgIGZvciAoOyBpIDwgazsgKSB7XG4gICAgICBuID0gZFtpXTtcbiAgICAgIGlmIChuID49IDQyOWU3KSB7XG4gICAgICAgIGRbaV0gPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZFtpKytdID0gbiAlIDFlNztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgZCA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDQpO1xuICAgIGZvciAoOyBpIDwgazsgKSB7XG4gICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMTI3KSA8PCAyNCk7XG4gICAgICBpZiAobiA+PSAyMTRlNykge1xuICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkuY29weShkLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkLnB1c2gobiAlIDFlNyk7XG4gICAgICAgIGkgKz0gNDtcbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGsgLyA0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcbiAgfVxuICBrID0gcmRbLS1pXTtcbiAgc2QgJT0gTE9HX0JBU0U7XG4gIGlmIChrICYmIHNkKSB7XG4gICAgbiA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gc2QpO1xuICAgIHJkW2ldID0gKGsgLyBuIHwgMCkgKiBuO1xuICB9XG4gIGZvciAoOyByZFtpXSA9PT0gMDsgaS0tKVxuICAgIHJkLnBvcCgpO1xuICBpZiAoaSA8IDApIHtcbiAgICBlID0gMDtcbiAgICByZCA9IFswXTtcbiAgfSBlbHNlIHtcbiAgICBlID0gLTE7XG4gICAgZm9yICg7IHJkWzBdID09PSAwOyBlIC09IExPR19CQVNFKVxuICAgICAgcmQuc2hpZnQoKTtcbiAgICBmb3IgKGsgPSAxLCBuID0gcmRbMF07IG4gPj0gMTA7IG4gLz0gMTApXG4gICAgICBrKys7XG4gICAgaWYgKGsgPCBMT0dfQkFTRSlcbiAgICAgIGUgLT0gTE9HX0JBU0UgLSBrO1xuICB9XG4gIHIuZSA9IGU7XG4gIHIuZCA9IHJkO1xuICByZXR1cm4gcjtcbn1cbl9fbmFtZShyYW5kb20sIFwicmFuZG9tXCIpO1xuZnVuY3Rpb24gcm91bmQoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCB0aGlzLnJvdW5kaW5nKTtcbn1cbl9fbmFtZShyb3VuZCwgXCJyb3VuZFwiKTtcbmZ1bmN0aW9uIHNpZ24oeCkge1xuICB4ID0gbmV3IHRoaXMoeCk7XG4gIHJldHVybiB4LmQgPyB4LmRbMF0gPyB4LnMgOiAwICogeC5zIDogeC5zIHx8IE5hTjtcbn1cbl9fbmFtZShzaWduLCBcInNpZ25cIik7XG5mdW5jdGlvbiBzaW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuc2luKCk7XG59XG5fX25hbWUoc2luLCBcInNpblwiKTtcbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuc2luaCgpO1xufVxuX19uYW1lKHNpbmgsIFwic2luaFwiKTtcbmZ1bmN0aW9uIHNxcnQoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuc3FydCgpO1xufVxuX19uYW1lKHNxcnQsIFwic3FydFwiKTtcbmZ1bmN0aW9uIHN1Yih4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zdWIoeSk7XG59XG5fX25hbWUoc3ViLCBcInN1YlwiKTtcbmZ1bmN0aW9uIHN1bSgpIHtcbiAgdmFyIGkgPSAwLCBhcmdzID0gYXJndW1lbnRzLCB4ID0gbmV3IHRoaXMoYXJnc1tpXSk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoOyB4LnMgJiYgKytpIDwgYXJncy5sZW5ndGg7IClcbiAgICB4ID0geC5wbHVzKGFyZ3NbaV0pO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZSh4LCB0aGlzLnByZWNpc2lvbiwgdGhpcy5yb3VuZGluZyk7XG59XG5fX25hbWUoc3VtLCBcInN1bVwiKTtcbmZ1bmN0aW9uIHRhbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW4oKTtcbn1cbl9fbmFtZSh0YW4sIFwidGFuXCIpO1xuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW5oKCk7XG59XG5fX25hbWUodGFuaCwgXCJ0YW5oXCIpO1xuZnVuY3Rpb24gdHJ1bmMoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAxKTtcbn1cbl9fbmFtZSh0cnVuYywgXCJ0cnVuY1wiKTtcblBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSA9IFAudG9TdHJpbmc7XG5QW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIkRlY2ltYWxcIjtcbnZhciBEZWNpbWFsID0gUC5jb25zdHJ1Y3RvciA9IGNsb25lKERFRkFVTFRTKTtcbkxOMTAgPSBuZXcgRGVjaW1hbChMTjEwKTtcblBJID0gbmV3IERlY2ltYWwoUEkpO1xudmFyIGRlY2ltYWxfZGVmYXVsdCA9IERlY2ltYWw7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRGVjaW1hbFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/runtime/index-browser.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Formi.module.css":
/*!*************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Formi.module.css ***!
  \*************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n\\r\\n.Formi_taulu__5_p7h {\\r\\n  margin:50px;\\r\\n  border:1px solid;\\r\\n}\\r\\n\\r\\n.Formi_taulunHeader__9_i_5{\\r\\n  background-color:lightgray;\\r\\n}\\r\\n  .Formi_form__YJyt6{\\r\\n    display:none;\\r\\n    margin-left: 20px; \\r\\n    margin-top: 100px;\\r\\n    padding: 0;\\r\\n    display:flex;\\r\\n    flex-direction: column;\\r\\n    flex-shrink:inherit;\\r\\n  }\\r\\n\\r\\n  .Formi_label__mDvtZ {    \\r\\n    line-height: 40px;    \\r\\n    font-size: 24px;\\r\\n    margin: 0 0 0 30px;\\r\\n    display: block;\\r\\n    pointer-events: none;\\r\\n    margin:10px;    \\r\\n  }\\r\\n\\r\\n  .Formi_input__mXlXa {\\r\\n    margin-left:20px;\\r\\n    margin-top:10px;\\r\\n    width: -webkit-fit-content;\\r\\n    width: -moz-fit-content;\\r\\n    width: fit-content;\\r\\n    height: 100%;\\r\\n    background: transparent;\\r\\n    outline: none;\\r\\n    font-size: 24px;\\r\\n    padding: 10px 0 10px 20px;\\r\\n    border: 5px solid rgba(0, 0, 0, 0.3);\\r\\n    box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.3);   \\r\\n    border-radius: 50px;\\r\\n  }\\r\\n\\r\\n  .Formi_output__GPFGx{\\r\\n      margin:200px;\\r\\n      color:red;\\r\\n  }\\r\\n\\r\\n  .Formi_button__IPBcF{ \\r\\n    border: 5px solid rgba(0, 0, 0, 0.3);\\r\\n    box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.3);\\r\\n    padding: 50px;\\r\\n    height: -webkit-fit-content;\\r\\n    height: -moz-fit-content;\\r\\n    height: fit-content;\\r\\n    width: -webkit-fit-content;\\r\\n    width: -moz-fit-content;\\r\\n    width: fit-content;\\r\\n    cursor: pointer;\\r\\n    outline: none;\\r\\n    background: transparent;\\r\\n    text-transform: uppercase;\\r\\n    line-height: 40px;\\r\\n    font-size: 14px;\\r\\n    font-weight: 700;\\r\\n    border-radius: 45px;\\r\\n    transition: all 0.4s;\\r\\n    margin-top:80px;\\r\\n    margin-left:50px;\\r\\n  }\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/Formi.module.css\"],\"names\":[],\"mappings\":\";;AAEA;EACE,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,0BAA0B;AAC5B;EACE;IACE,YAAY;IACZ,iBAAiB;IACjB,iBAAiB;IACjB,UAAU;IACV,YAAY;IACZ,sBAAsB;IACtB,mBAAmB;EACrB;;EAEA;IACE,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,cAAc;IACd,oBAAoB;IACpB,WAAW;EACb;;EAEA;IACE,gBAAgB;IAChB,eAAe;IACf,0BAAkB;IAAlB,uBAAkB;IAAlB,kBAAkB;IAClB,YAAY;IACZ,uBAAuB;IACvB,aAAa;IACb,eAAe;IACf,yBAAyB;IACzB,oCAAoC;IACpC,0CAA0C;IAC1C,mBAAmB;EACrB;;EAEA;MACI,YAAY;MACZ,SAAS;EACb;;EAEA;IACE,oCAAoC;IACpC,0CAA0C;IAC1C,aAAa;IACb,2BAAmB;IAAnB,wBAAmB;IAAnB,mBAAmB;IACnB,0BAAkB;IAAlB,uBAAkB;IAAlB,kBAAkB;IAClB,eAAe;IACf,aAAa;IACb,uBAAuB;IACvB,yBAAyB;IACzB,iBAAiB;IACjB,eAAe;IACf,gBAAgB;IAChB,mBAAmB;IACnB,oBAAoB;IACpB,eAAe;IACf,gBAAgB;EAClB\",\"sourcesContent\":[\"\\r\\n\\r\\n.taulu {\\r\\n  margin:50px;\\r\\n  border:1px solid;\\r\\n}\\r\\n\\r\\n.taulunHeader{\\r\\n  background-color:lightgray;\\r\\n}\\r\\n  .form{\\r\\n    display:none;\\r\\n    margin-left: 20px; \\r\\n    margin-top: 100px;\\r\\n    padding: 0;\\r\\n    display:flex;\\r\\n    flex-direction: column;\\r\\n    flex-shrink:inherit;\\r\\n  }\\r\\n\\r\\n  .label {    \\r\\n    line-height: 40px;    \\r\\n    font-size: 24px;\\r\\n    margin: 0 0 0 30px;\\r\\n    display: block;\\r\\n    pointer-events: none;\\r\\n    margin:10px;    \\r\\n  }\\r\\n\\r\\n  .input {\\r\\n    margin-left:20px;\\r\\n    margin-top:10px;\\r\\n    width: fit-content;\\r\\n    height: 100%;\\r\\n    background: transparent;\\r\\n    outline: none;\\r\\n    font-size: 24px;\\r\\n    padding: 10px 0 10px 20px;\\r\\n    border: 5px solid rgba(0, 0, 0, 0.3);\\r\\n    box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.3);   \\r\\n    border-radius: 50px;\\r\\n  }\\r\\n\\r\\n  .output{\\r\\n      margin:200px;\\r\\n      color:red;\\r\\n  }\\r\\n\\r\\n  .button{ \\r\\n    border: 5px solid rgba(0, 0, 0, 0.3);\\r\\n    box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.3);\\r\\n    padding: 50px;\\r\\n    height: fit-content;\\r\\n    width: fit-content;\\r\\n    cursor: pointer;\\r\\n    outline: none;\\r\\n    background: transparent;\\r\\n    text-transform: uppercase;\\r\\n    line-height: 40px;\\r\\n    font-size: 14px;\\r\\n    font-weight: 700;\\r\\n    border-radius: 45px;\\r\\n    transition: all 0.4s;\\r\\n    margin-top:80px;\\r\\n    margin-left:50px;\\r\\n  }\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"taulu\": \"Formi_taulu__5_p7h\",\n\t\"taulunHeader\": \"Formi_taulunHeader__9_i_5\",\n\t\"form\": \"Formi_form__YJyt6\",\n\t\"label\": \"Formi_label__mDvtZ\",\n\t\"input\": \"Formi_input__mXlXa\",\n\t\"output\": \"Formi_output__GPFGx\",\n\t\"button\": \"Formi_button__IPBcF\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3R5bGVzL0Zvcm1pLm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxtS0FBK0U7QUFDekg7QUFDQTtBQUNBLHVFQUF1RSxrQkFBa0IsdUJBQXVCLEtBQUssbUNBQW1DLGlDQUFpQyxLQUFLLHlCQUF5QixxQkFBcUIsMkJBQTJCLDBCQUEwQixtQkFBbUIscUJBQXFCLCtCQUErQiw0QkFBNEIsT0FBTyxtQ0FBbUMsOEJBQThCLHdCQUF3QiwyQkFBMkIsdUJBQXVCLDZCQUE2Qix3QkFBd0IsT0FBTywrQkFBK0IseUJBQXlCLHdCQUF3QixtQ0FBbUMsZ0NBQWdDLDJCQUEyQixxQkFBcUIsZ0NBQWdDLHNCQUFzQix3QkFBd0Isa0NBQWtDLDZDQUE2QyxzREFBc0QsNEJBQTRCLE9BQU8sK0JBQStCLHVCQUF1QixvQkFBb0IsT0FBTyxnQ0FBZ0MsNkNBQTZDLG1EQUFtRCxzQkFBc0Isb0NBQW9DLGlDQUFpQyw0QkFBNEIsbUNBQW1DLGdDQUFnQywyQkFBMkIsd0JBQXdCLHNCQUFzQixnQ0FBZ0Msa0NBQWtDLDBCQUEwQix3QkFBd0IseUJBQXlCLDRCQUE0Qiw2QkFBNkIsd0JBQXdCLHlCQUF5QixPQUFPLE9BQU8scUZBQXFGLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxXQUFXLFlBQVksV0FBVyxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsYUFBYSxXQUFXLFlBQVksMENBQTBDLGtCQUFrQix1QkFBdUIsS0FBSyxzQkFBc0IsaUNBQWlDLEtBQUssWUFBWSxxQkFBcUIsMkJBQTJCLDBCQUEwQixtQkFBbUIscUJBQXFCLCtCQUErQiw0QkFBNEIsT0FBTyxzQkFBc0IsOEJBQThCLHdCQUF3QiwyQkFBMkIsdUJBQXVCLDZCQUE2Qix3QkFBd0IsT0FBTyxrQkFBa0IseUJBQXlCLHdCQUF3QiwyQkFBMkIscUJBQXFCLGdDQUFnQyxzQkFBc0Isd0JBQXdCLGtDQUFrQyw2Q0FBNkMsc0RBQXNELDRCQUE0QixPQUFPLGtCQUFrQix1QkFBdUIsb0JBQW9CLE9BQU8sbUJBQW1CLDZDQUE2QyxtREFBbUQsc0JBQXNCLDRCQUE0QiwyQkFBMkIsd0JBQXdCLHNCQUFzQixnQ0FBZ0Msa0NBQWtDLDBCQUEwQix3QkFBd0IseUJBQXlCLDRCQUE0Qiw2QkFBNkIsd0JBQXdCLHlCQUF5QixPQUFPLG1CQUFtQjtBQUN6NUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvRm9ybWkubW9kdWxlLmNzcz85MDBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXHJcXG5cXHJcXG4uRm9ybWlfdGF1bHVfXzVfcDdoIHtcXHJcXG4gIG1hcmdpbjo1MHB4O1xcclxcbiAgYm9yZGVyOjFweCBzb2xpZDtcXHJcXG59XFxyXFxuXFxyXFxuLkZvcm1pX3RhdWx1bkhlYWRlcl9fOV9pXzV7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOmxpZ2h0Z3JheTtcXHJcXG59XFxyXFxuICAuRm9ybWlfZm9ybV9fWUp5dDZ7XFxyXFxuICAgIGRpc3BsYXk6bm9uZTtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7IFxcclxcbiAgICBtYXJnaW4tdG9wOiAxMDBweDtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBmbGV4LXNocmluazppbmhlcml0O1xcclxcbiAgfVxcclxcblxcclxcbiAgLkZvcm1pX2xhYmVsX19tRHZ0WiB7ICAgIFxcclxcbiAgICBsaW5lLWhlaWdodDogNDBweDsgICAgXFxyXFxuICAgIGZvbnQtc2l6ZTogMjRweDtcXHJcXG4gICAgbWFyZ2luOiAwIDAgMCAzMHB4O1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICAgIG1hcmdpbjoxMHB4OyAgICBcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5Gb3JtaV9pbnB1dF9fbVhsWGEge1xcclxcbiAgICBtYXJnaW4tbGVmdDoyMHB4O1xcclxcbiAgICBtYXJnaW4tdG9wOjEwcHg7XFxyXFxuICAgIHdpZHRoOiAtd2Via2l0LWZpdC1jb250ZW50O1xcclxcbiAgICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXHJcXG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICBmb250LXNpemU6IDI0cHg7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHggMCAxMHB4IDIwcHg7XFxyXFxuICAgIGJvcmRlcjogNXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtcXHJcXG4gICAgYm94LXNoYWRvdzogMTBweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjMpOyAgIFxcclxcbiAgICBib3JkZXItcmFkaXVzOiA1MHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLkZvcm1pX291dHB1dF9fR1BGR3h7XFxyXFxuICAgICAgbWFyZ2luOjIwMHB4O1xcclxcbiAgICAgIGNvbG9yOnJlZDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5Gb3JtaV9idXR0b25fX0lQQmNGeyBcXHJcXG4gICAgYm9yZGVyOiA1cHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjMpO1xcclxcbiAgICBib3gtc2hhZG93OiAxMHB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMyk7XFxyXFxuICAgIHBhZGRpbmc6IDUwcHg7XFxyXFxuICAgIGhlaWdodDogLXdlYmtpdC1maXQtY29udGVudDtcXHJcXG4gICAgaGVpZ2h0OiAtbW96LWZpdC1jb250ZW50O1xcclxcbiAgICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcclxcbiAgICB3aWR0aDogLXdlYmtpdC1maXQtY29udGVudDtcXHJcXG4gICAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XFxyXFxuICAgIHdpZHRoOiBmaXQtY29udGVudDtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDQwcHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNDVweDtcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNHM7XFxyXFxuICAgIG1hcmdpbi10b3A6ODBweDtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6NTBweDtcXHJcXG4gIH1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3R5bGVzL0Zvcm1pLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSwwQkFBMEI7QUFDNUI7RUFDRTtJQUNFLFlBQVk7SUFDWixpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLFVBQVU7SUFDVixZQUFZO0lBQ1osc0JBQXNCO0lBQ3RCLG1CQUFtQjtFQUNyQjs7RUFFQTtJQUNFLGlCQUFpQjtJQUNqQixlQUFlO0lBQ2Ysa0JBQWtCO0lBQ2xCLGNBQWM7SUFDZCxvQkFBb0I7SUFDcEIsV0FBVztFQUNiOztFQUVBO0lBQ0UsZ0JBQWdCO0lBQ2hCLGVBQWU7SUFDZiwwQkFBa0I7SUFBbEIsdUJBQWtCO0lBQWxCLGtCQUFrQjtJQUNsQixZQUFZO0lBQ1osdUJBQXVCO0lBQ3ZCLGFBQWE7SUFDYixlQUFlO0lBQ2YseUJBQXlCO0lBQ3pCLG9DQUFvQztJQUNwQywwQ0FBMEM7SUFDMUMsbUJBQW1CO0VBQ3JCOztFQUVBO01BQ0ksWUFBWTtNQUNaLFNBQVM7RUFDYjs7RUFFQTtJQUNFLG9DQUFvQztJQUNwQywwQ0FBMEM7SUFDMUMsYUFBYTtJQUNiLDJCQUFtQjtJQUFuQix3QkFBbUI7SUFBbkIsbUJBQW1CO0lBQ25CLDBCQUFrQjtJQUFsQix1QkFBa0I7SUFBbEIsa0JBQWtCO0lBQ2xCLGVBQWU7SUFDZixhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLHlCQUF5QjtJQUN6QixpQkFBaUI7SUFDakIsZUFBZTtJQUNmLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsb0JBQW9CO0lBQ3BCLGVBQWU7SUFDZixnQkFBZ0I7RUFDbEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiXFxyXFxuXFxyXFxuLnRhdWx1IHtcXHJcXG4gIG1hcmdpbjo1MHB4O1xcclxcbiAgYm9yZGVyOjFweCBzb2xpZDtcXHJcXG59XFxyXFxuXFxyXFxuLnRhdWx1bkhlYWRlcntcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6bGlnaHRncmF5O1xcclxcbn1cXHJcXG4gIC5mb3Jte1xcclxcbiAgICBkaXNwbGF5Om5vbmU7XFxyXFxuICAgIG1hcmdpbi1sZWZ0OiAyMHB4OyBcXHJcXG4gICAgbWFyZ2luLXRvcDogMTAwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgZmxleC1zaHJpbms6aW5oZXJpdDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5sYWJlbCB7ICAgIFxcclxcbiAgICBsaW5lLWhlaWdodDogNDBweDsgICAgXFxyXFxuICAgIGZvbnQtc2l6ZTogMjRweDtcXHJcXG4gICAgbWFyZ2luOiAwIDAgMCAzMHB4O1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICAgIG1hcmdpbjoxMHB4OyAgICBcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5pbnB1dCB7XFxyXFxuICAgIG1hcmdpbi1sZWZ0OjIwcHg7XFxyXFxuICAgIG1hcmdpbi10b3A6MTBweDtcXHJcXG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICBmb250LXNpemU6IDI0cHg7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHggMCAxMHB4IDIwcHg7XFxyXFxuICAgIGJvcmRlcjogNXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtcXHJcXG4gICAgYm94LXNoYWRvdzogMTBweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjMpOyAgIFxcclxcbiAgICBib3JkZXItcmFkaXVzOiA1MHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLm91dHB1dHtcXHJcXG4gICAgICBtYXJnaW46MjAwcHg7XFxyXFxuICAgICAgY29sb3I6cmVkO1xcclxcbiAgfVxcclxcblxcclxcbiAgLmJ1dHRvbnsgXFxyXFxuICAgIGJvcmRlcjogNXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtcXHJcXG4gICAgYm94LXNoYWRvdzogMTBweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjMpO1xcclxcbiAgICBwYWRkaW5nOiA1MHB4O1xcclxcbiAgICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcclxcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgb3V0bGluZTogbm9uZTtcXHJcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xcclxcbiAgICBmb250LXNpemU6IDE0cHg7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDQ1cHg7XFxyXFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjRzO1xcclxcbiAgICBtYXJnaW4tdG9wOjgwcHg7XFxyXFxuICAgIG1hcmdpbi1sZWZ0OjUwcHg7XFxyXFxuICB9XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwidGF1bHVcIjogXCJGb3JtaV90YXVsdV9fNV9wN2hcIixcblx0XCJ0YXVsdW5IZWFkZXJcIjogXCJGb3JtaV90YXVsdW5IZWFkZXJfXzlfaV81XCIsXG5cdFwiZm9ybVwiOiBcIkZvcm1pX2Zvcm1fX1lKeXQ2XCIsXG5cdFwibGFiZWxcIjogXCJGb3JtaV9sYWJlbF9fbUR2dFpcIixcblx0XCJpbnB1dFwiOiBcIkZvcm1pX2lucHV0X19tWGxYYVwiLFxuXHRcIm91dHB1dFwiOiBcIkZvcm1pX291dHB1dF9fR1BGR3hcIixcblx0XCJidXR0b25cIjogXCJGb3JtaV9idXR0b25fX0lQQmNGXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Formi.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Nav.module.css":
/*!***********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Nav.module.css ***!
  \***********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Nav_nav__Bx_p6{\\r\\n    height:50px;\\r\\n    padding: 10px;\\r\\n    background: #000;\\r\\n    color: #fff;\\r\\n    display:flex;\\r\\n    align-items:center;\\r\\n    justify-content: flex-start;\\r\\n  }\\r\\n  \\r\\n  .Nav_nav__Bx_p6 ul{\\r\\n    display:flex;\\r\\n    justify-content: center;\\r\\n    align-items: center;\\r\\n    list-style: none;\\r\\n  }\\r\\n  \\r\\n  .Nav_nav__Bx_p6 ul li a {\\r\\n    margin: 5px 15px;\\r\\n    color:white;\\r\\n  }\\r\\n\\r\\n  .Nav_nav__Bx_p6 Link{\\r\\n    color:red;\\r\\n  }\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/Nav.module.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,WAAW;IACX,aAAa;IACb,gBAAgB;IAChB,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,2BAA2B;EAC7B;;EAEA;IACE,YAAY;IACZ,uBAAuB;IACvB,mBAAmB;IACnB,gBAAgB;EAClB;;EAEA;IACE,gBAAgB;IAChB,WAAW;EACb;;EAEA;IACE,SAAS;EACX\",\"sourcesContent\":[\".nav{\\r\\n    height:50px;\\r\\n    padding: 10px;\\r\\n    background: #000;\\r\\n    color: #fff;\\r\\n    display:flex;\\r\\n    align-items:center;\\r\\n    justify-content: flex-start;\\r\\n  }\\r\\n  \\r\\n  .nav ul{\\r\\n    display:flex;\\r\\n    justify-content: center;\\r\\n    align-items: center;\\r\\n    list-style: none;\\r\\n  }\\r\\n  \\r\\n  .nav ul li a {\\r\\n    margin: 5px 15px;\\r\\n    color:white;\\r\\n  }\\r\\n\\r\\n  .nav Link{\\r\\n    color:red;\\r\\n  }\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"nav\": \"Nav_nav__Bx_p6\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3R5bGVzL05hdi5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsbUtBQStFO0FBQ3pIO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CLHNCQUFzQix5QkFBeUIsb0JBQW9CLHFCQUFxQiwyQkFBMkIsb0NBQW9DLE9BQU8sK0JBQStCLHFCQUFxQixnQ0FBZ0MsNEJBQTRCLHlCQUF5QixPQUFPLHFDQUFxQyx5QkFBeUIsb0JBQW9CLE9BQU8sK0JBQStCLGtCQUFrQixPQUFPLE9BQU8sc0ZBQXNGLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSw4QkFBOEIsb0JBQW9CLHNCQUFzQix5QkFBeUIsb0JBQW9CLHFCQUFxQiwyQkFBMkIsb0NBQW9DLE9BQU8sb0JBQW9CLHFCQUFxQixnQ0FBZ0MsNEJBQTRCLHlCQUF5QixPQUFPLDBCQUEwQix5QkFBeUIsb0JBQW9CLE9BQU8sb0JBQW9CLGtCQUFrQixPQUFPLG1CQUFtQjtBQUMvd0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvTmF2Lm1vZHVsZS5jc3M/NDFiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLk5hdl9uYXZfX0J4X3A2e1xcclxcbiAgICBoZWlnaHQ6NTBweDtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgYmFja2dyb3VuZDogIzAwMDtcXHJcXG4gICAgY29sb3I6ICNmZmY7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAgYWxpZ24taXRlbXM6Y2VudGVyO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5OYXZfbmF2X19CeF9wNiB1bHtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLk5hdl9uYXZfX0J4X3A2IHVsIGxpIGEge1xcclxcbiAgICBtYXJnaW46IDVweCAxNXB4O1xcclxcbiAgICBjb2xvcjp3aGl0ZTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5OYXZfbmF2X19CeF9wNiBMaW5re1xcclxcbiAgICBjb2xvcjpyZWQ7XFxyXFxuICB9XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy9OYXYubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLFdBQVc7SUFDWCxhQUFhO0lBQ2IsZ0JBQWdCO0lBQ2hCLFdBQVc7SUFDWCxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLDJCQUEyQjtFQUM3Qjs7RUFFQTtJQUNFLFlBQVk7SUFDWix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLGdCQUFnQjtFQUNsQjs7RUFFQTtJQUNFLGdCQUFnQjtJQUNoQixXQUFXO0VBQ2I7O0VBRUE7SUFDRSxTQUFTO0VBQ1hcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLm5hdntcXHJcXG4gICAgaGVpZ2h0OjUwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAgIGJhY2tncm91bmQ6ICMwMDA7XFxyXFxuICAgIGNvbG9yOiAjZmZmO1xcclxcbiAgICBkaXNwbGF5OmZsZXg7XFxyXFxuICAgIGFsaWduLWl0ZW1zOmNlbnRlcjtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAubmF2IHVse1xcclxcbiAgICBkaXNwbGF5OmZsZXg7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAubmF2IHVsIGxpIGEge1xcclxcbiAgICBtYXJnaW46IDVweCAxNXB4O1xcclxcbiAgICBjb2xvcjp3aGl0ZTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5uYXYgTGlua3tcXHJcXG4gICAgY29sb3I6cmVkO1xcclxcbiAgfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcIm5hdlwiOiBcIk5hdl9uYXZfX0J4X3A2XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Nav.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return '@media '.concat(item[2], ' {').concat(content, '}');\n            }\n            return content;\n        }).join('');\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === 'string') {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    ''\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || '' // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === 'function') {\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return '/*# sourceURL='.concat(cssMapping.sourceRoot || '').concat(source, ' */');\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join('\\n');\n    }\n    return [\n        content\n    ].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);\n    return '/*# '.concat(data, ' */');\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQG1lZGlhICcuY29uY2F0KGl0ZW1bMl0sICcgeycpLmNvbmNhdChjb250ZW50LCAnfScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH0gLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgICA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBtb2R1bGVzID0gW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gJycuY29uY2F0KG1lZGlhUXVlcnksICcgYW5kICcpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBsaXN0O1xufTtcbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgICAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8qIyBzb3VyY2VVUkw9Jy5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCAnICovJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY29udGVudFxuICAgICAgICBdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ1xuICAgICAgICBdKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudFxuICAgIF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnLmNvbmNhdChiYXNlNjQpO1xuICAgIHJldHVybiAnLyojICcuY29uY2F0KGRhdGEsICcgKi8nKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CJouniRiimala%5CDocuments%5Crepo%5CRekisteri%5Cpages%5CHuolto%5ClisaaHuolto.js&page=%2FHuolto%2FlisaaHuolto!":
/*!******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CJouniRiimala%5CDocuments%5Crepo%5CRekisteri%5Cpages%5CHuolto%5ClisaaHuolto.js&page=%2FHuolto%2FlisaaHuolto! ***!
  \******************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/Huolto/lisaaHuolto\",\n      function () {\n        return __webpack_require__(/*! ./pages/Huolto/lisaaHuolto.js */ \"./pages/Huolto/lisaaHuolto.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/Huolto/lisaaHuolto\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNKb3VuaVJpaW1hbGElNUNEb2N1bWVudHMlNUNyZXBvJTVDUmVraXN0ZXJpJTVDcGFnZXMlNUNIdW9sdG8lNUNsaXNhYUh1b2x0by5qcyZwYWdlPSUyRkh1b2x0byUyRmxpc2FhSHVvbHRvIS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG9FQUErQjtBQUN0RDtBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MTM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL0h1b2x0by9saXNhYUh1b2x0b1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvSHVvbHRvL2xpc2FhSHVvbHRvLmpzXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9IdW9sdG8vbGlzYWFIdW9sdG9cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CJouniRiimala%5CDocuments%5Crepo%5CRekisteri%5Cpages%5CHuolto%5ClisaaHuolto.js&page=%2FHuolto%2FlisaaHuolto!\n");

/***/ }),

/***/ "./styles/Formi.module.css":
/*!*********************************!*\
  !*** ./styles/Formi.module.css ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Formi.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Formi.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Formi.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Formi.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Formi.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Formi.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvRm9ybWkubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsb05BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLGlmQUFvUDs7QUFFdFI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0saWZBQW9QO0FBQzFQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaWZBQW9QOztBQUU5UTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvRm9ybWkubW9kdWxlLmNzcz80Y2FhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL0Zvcm1pLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vRm9ybWkubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9Gb3JtaS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/Formi.module.css\n");

/***/ }),

/***/ "./styles/Nav.module.css":
/*!*******************************!*\
  !*** ./styles/Nav.module.css ***!
  \*******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Nav.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Nav.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Nav.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Nav.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Nav.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Nav.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvTmF2Lm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyw2ZUFBa1A7O0FBRXBSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLDZlQUFrUDtBQUN4UDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDZlQUFrUDs7QUFFNVE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL05hdi5tb2R1bGUuY3NzP2JmODUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vTmF2Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vTmF2Lm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vTmF2Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/Nav.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === 'undefined') {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === 'undefined') {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + ' ' + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement('style');\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === 'undefined') {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === 'function') {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || 'head');\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join('\\n');\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? '' : obj.media ? '@media ' + obj.media + ' {' + obj.css + '}' : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute('media', media);\n    } else {\n        style.removeAttribute('media');\n    }\n    if (sourceMap && typeof btoa !== 'undefined') {\n        css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== 'boolean') {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== '[object Array]') {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xufSgpO1xuY29uc3QgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICAgIGNvbnN0IG1lbW8gPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyAnICcgKyBjb3VudC50b1N0cmluZygpO1xuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi8gY29uc3QgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgICBjb25zdCB0ZXh0U3RvcmUgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyAnQG1lZGlhICcgKyBvYmoubWVkaWEgKyAnIHsnICsgb2JqLmNzcyArICd9JyA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICAgIGxldCBjc3MgPSBvYmouY3NzO1xuICAgIGNvbnN0IG1lZGlhID0gb2JqLm1lZGlhO1xuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJztcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgICB9XG4gICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICAgICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaTEgPSAwOyBpMSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkxKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpMV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgICB9O1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./components/Nav.js":
/*!***************************!*\
  !*** ./components/Nav.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getInitialProps\": function() { return /* binding */ getInitialProps; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! .prisma/client */ \"./node_modules/.prisma/client/index-browser.js\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_Nav_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/Nav.module.css */ \"./styles/Nav.module.css\");\n/* harmony import */ var _styles_Nav_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_Nav_module_css__WEBPACK_IMPORTED_MODULE_3__);\nvar _this = undefined;\n\n\n\n\nvar Nav = function() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Nav_module_css__WEBPACK_IMPORTED_MODULE_3___default().nav),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                        href: \"/Kontaktit\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            children: \"Kontaktit\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                            lineNumber: 10,\n                            columnNumber: 47\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                        lineNumber: 10,\n                        columnNumber: 21\n                    }, _this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                    lineNumber: 9,\n                    columnNumber: 17\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                        href: \"/Huolto\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            children: \"Huollot\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                            lineNumber: 13,\n                            columnNumber: 44\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                        lineNumber: 13,\n                        columnNumber: 21\n                    }, _this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                    lineNumber: 12,\n                    columnNumber: 17\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                        href: \"/About\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            children: \"About\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                            lineNumber: 16,\n                            columnNumber: 43\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                        lineNumber: 16,\n                        columnNumber: 21\n                    }, _this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n                    lineNumber: 15,\n                    columnNumber: 17\n                }, _this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n            lineNumber: 8,\n            columnNumber: 13\n        }, _this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\components\\\\Nav.js\",\n        lineNumber: 7,\n        columnNumber: 9\n    }, _this);\n};\n_c = Nav;\nvar prisma;\nvar getInitialProps = function() {\n    prisma = new _prisma_client__WEBPACK_IMPORTED_MODULE_1__.PrismaClient();\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Nav);\nvar _c;\n$RefreshReg$(_c, \"Nav\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL05hdi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFBNkM7QUFDakI7QUFDb0I7QUFFaEQsSUFBTUcsR0FBRyxHQUFHLFdBQU07SUFDZCxxQkFDSSw4REFBQ0MsS0FBRztRQUFDQyxTQUFTLEVBQUVILG1FQUFhO2tCQUN6Qiw0RUFBQ0ssSUFBRTs7OEJBQ0MsOERBQUNDLElBQUU7OEJBQ0MsNEVBQUNQLGtEQUFJO3dCQUFDUSxJQUFJLEVBQUcsWUFBWTtrQ0FBQyw0RUFBQ0MsR0FBQztzQ0FBQyxXQUFTOzs7OztpQ0FBSTs7Ozs7NkJBQU87Ozs7O3lCQUNoRDs4QkFDTCw4REFBQ0YsSUFBRTs4QkFDQyw0RUFBQ1Asa0RBQUk7d0JBQUNRLElBQUksRUFBRyxTQUFTO2tDQUFDLDRFQUFDQyxHQUFDO3NDQUFDLFNBQU87Ozs7O2lDQUFJOzs7Ozs2QkFBTzs7Ozs7eUJBQzNDOzhCQUNMLDhEQUFDRixJQUFFOzhCQUNDLDRFQUFDUCxrREFBSTt3QkFBQ1EsSUFBSSxFQUFHLFFBQVE7a0NBQUMsNEVBQUNDLEdBQUM7c0NBQUMsT0FBSzs7Ozs7aUNBQUk7Ozs7OzZCQUFPOzs7Ozt5QkFDeEM7Ozs7OztpQkFFSjs7Ozs7YUFDSCxDQUNUO0NBRUo7QUFsQktQLEtBQUFBLEdBQUc7QUFvQlQsSUFBSVEsTUFBTTtBQUNILElBQU1DLGVBQWUsR0FBRyxXQUFNO0lBQ2pDRCxNQUFNLEdBQUcsSUFBSVgsd0RBQVksRUFBRTtDQUM5QjtBQUVELCtEQUFlRyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvTmF2LmpzPzg2NGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSAnLnByaXNtYS9jbGllbnQnXHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluaydcclxuaW1wb3J0IG5hdlN0eWxlcyBmcm9tICcuLi9zdHlsZXMvTmF2Lm1vZHVsZS5jc3MnXHJcblxyXG5jb25zdCBOYXYgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4oXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e25hdlN0eWxlcy5uYXZ9PiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZiA9IFwiL0tvbnRha3RpdFwiPjxhPktvbnRha3RpdDwvYT48L0xpbms+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWYgPSBcIi9IdW9sdG9cIj48YT5IdW9sbG90PC9hPjwvTGluaz5cclxuICAgICAgICAgICAgICAgIDwvbGk+ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWYgPSBcIi9BYm91dFwiPjxhPkFib3V0PC9hPjwvTGluaz5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcblxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG5cclxufVxyXG5cclxudmFyIHByaXNtYTtcclxuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxQcm9wcyA9ICgpID0+IHsgICAgXHJcbiAgICBwcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KCkgICBcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTmF2Il0sIm5hbWVzIjpbIlByaXNtYUNsaWVudCIsIkxpbmsiLCJuYXZTdHlsZXMiLCJOYXYiLCJkaXYiLCJjbGFzc05hbWUiLCJuYXYiLCJ1bCIsImxpIiwiaHJlZiIsImEiLCJwcmlzbWEiLCJnZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Nav.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nvar _typeof = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _router1 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar prefetched = {};\nfunction prefetch(router, href, as, options) {\n    if ( false || !router) return;\n    if (!(0, _router).isLocalURL(href)) return;\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    router.prefetch(href, as, options).catch(function(err) {\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n    var curLocale = options && typeof options.locale !== \"undefined\" ? options.locale : router && router.locale;\n    // Join on an invalid URI character\n    prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")] = true;\n}\nfunction isModifiedEvent(event) {\n    var target = event.currentTarget.target;\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale) {\n    var nodeName = e.currentTarget.nodeName;\n    // anchors inside an svg have a lowercase nodeName\n    var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    // replace state instead of push if prop is present\n    router[replace ? \"replace\" : \"push\"](href, as, {\n        shallow: shallow,\n        locale: locale,\n        scroll: scroll\n    });\n}\nvar Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function(props, forwardedRef) {\n    _s();\n    var _legacyBehavior = props.legacyBehavior, legacyBehavior = _legacyBehavior === void 0 ? Boolean(false) !== true : _legacyBehavior;\n    if (true) {\n        var createPropError = function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        };\n        // TypeScript trick for type-guarding:\n        var requiredPropsGuard = {\n            href: true\n        };\n        var requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach(function(key) {\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : _typeof(props[key])\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        var optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            legacyBehavior: true\n        };\n        var optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach(function(key) {\n            var valType = _typeof(props[key]);\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        var hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    var children;\n    var hrefProp = props.href, asProp = props.as, childrenProp = props.children, prefetchProp = props.prefetch, passHref = props.passHref, replace = props.replace, shallow = props.shallow, scroll = props.scroll, locale = props.locale, onClick = props.onClick, onMouseEnter = props.onMouseEnter, restProps = _objectWithoutProperties(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && typeof children === \"string\") {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    var p = prefetchProp !== false;\n    var router = (0, _router1).useRouter();\n    var ref2 = _react.default.useMemo(function() {\n        var ref = _slicedToArray((0, _router).resolveHref(router, hrefProp, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _router).resolveHref(router, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        router,\n        hrefProp,\n        asProp\n    ]), href = ref2.href, as = ref2.as;\n    var previousHref = _react.default.useRef(href);\n    var previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    var child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n            }\n            if (onMouseEnter) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    }\n    var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n        rootMargin: \"200px\"\n    }), 3), setIntersectionRef = ref1[0], isVisible = ref1[1], resetVisible = ref1[2];\n    var setRef = _react.default.useCallback(function(el) {\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    _react.default.useEffect(function() {\n        var shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);\n        var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale;\n        var isPrefetched = prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")];\n        if (shouldPrefetch && !isPrefetched) {\n            prefetch(router, href, as, {\n                locale: curLocale\n            });\n        }\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        p,\n        router\n    ]);\n    var childProps = {\n        ref: setRef,\n        onClick: function(e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!e.defaultPrevented) {\n                linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n            }\n        },\n        onMouseEnter: function(e) {\n            if (!legacyBehavior && typeof onMouseEnter === \"function\") {\n                onMouseEnter(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if ((0, _router).isLocalURL(href)) {\n                prefetch(router, href, as, {\n                    priority: true\n                });\n            }\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user\n    if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        var curLocale1 = typeof locale !== \"undefined\" ? locale : router && router.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        var localeDomain = router && router.isLocaleDomain && (0, _router).getDomainLocale(as, curLocale1, router && router.locales, router && router.domainLocales);\n        childProps.href = localeDomain || (0, _router).addBasePath((0, _router).addLocale(as, curLocale1, router && router.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"0ZFEvDsMcGa6STfdR5LB+2RmtYc=\")), \"0ZFEvDsMcGa6STfdR5LB+2RmtYc=\");\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\nif (typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) {\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFLElBQUk7Q0FDZCxFQUFDLENBQUM7QUFDSEQsa0JBQWUsR0FBRyxLQUFLLENBQUMsQ0FBQztBQUN6QixJQUFJRyxNQUFNLEdBQUdDLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLDRDQUFPLENBQUMsQ0FBQztBQUNyRCxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMseUZBQTZCLENBQUM7QUFDcEQsSUFBSUUsUUFBUSxHQUFHRixtQkFBTyxDQUFDLDJEQUFVLENBQUM7QUFDbEMsSUFBSUcsZ0JBQWdCLEdBQUdILG1CQUFPLENBQUMsK0VBQW9CLENBQUM7QUFDcEQsU0FBU0Qsc0JBQXNCLENBQUNLLEdBQUcsRUFBRTtJQUNqQyxPQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHRCxHQUFHLEdBQUc7UUFDakNQLE9BQU8sRUFBRU8sR0FBRztLQUNmLENBQUM7Q0FDTDtBQUNELFNBQVNFLHdCQUF3QixDQUFDQyxNQUFNLEVBQUVDLFFBQVEsRUFBRTtJQUNoRCxJQUFJRCxNQUFNLElBQUksSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDO0lBQzlCLElBQUlFLE1BQU0sR0FBR0MsNkJBQTZCLENBQUNILE1BQU0sRUFBRUMsUUFBUSxDQUFDO0lBQzVELElBQUlHLEdBQUcsRUFBRUMsQ0FBQztJQUNWLElBQUluQixNQUFNLENBQUNvQixxQkFBcUIsRUFBRTtRQUM5QixJQUFJQyxnQkFBZ0IsR0FBR3JCLE1BQU0sQ0FBQ29CLHFCQUFxQixDQUFDTixNQUFNLENBQUM7UUFDM0QsSUFBSUssQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRSxnQkFBZ0IsQ0FBQ0MsTUFBTSxFQUFFSCxDQUFDLEVBQUUsQ0FB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LENBQUN5RixhQUFhLENBQUMsR0FBRyxFQUFFN0YsTUFBTSxDQUFDbUksTUFBTSxDQUFDLEVBQUUsRUFBRXZDLFNBQVMsRUFBRTBCLFVBQVUsQ0FBQyxFQUFFL0IsUUFBUSxDQUFDLENBQUM7Q0FDOUwsa0NBQUM7O0FBQ0YsSUFBSTZDLFFBQVEsR0FBR3pFLElBQUk7QUFDbkJ6RCxrQkFBZSxHQUFHa0ksUUFBUSxDQUFDO0FBRTNCLElBQUksT0FBT2xJLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLFVBQVUsSUFBSyxPQUFPRixPQUFPLENBQUNFLE9BQU8sS0FBSyxRQUFRLElBQUlGLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLElBQUksRUFBRztJQUM5R0osTUFBTSxDQUFDbUksTUFBTSxDQUFDakksT0FBTyxDQUFDRSxPQUFPLEVBQUVGLE9BQU8sQ0FBQyxDQUFDO0lBQ3hDbUksTUFBTSxDQUFDbkksT0FBTyxHQUFHQSxPQUFPLENBQUNFLE9BQU8sQ0FBQztDQUNsQyxDQUVELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9yb3V0ZXIxID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xudmFyIF91c2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi91c2UtaW50ZXJzZWN0aW9uXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3QgcHJlZmV0Y2hlZCA9IHt9O1xuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhcm91dGVyKSByZXR1cm47XG4gICAgaWYgKCEoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuO1xuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY3VyTG9jYWxlID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXQgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgISgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XG4gICAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XG4gICAgICAgIHNoYWxsb3csXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgc2Nyb2xsXG4gICAgfSk7XG59XG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKT0+e1xuICAgIGNvbnN0IHsgbGVnYWN5QmVoYXZpb3IgPUJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX05FV19MSU5LX0JFSEFWSU9SKSAhPT0gdHJ1ZSAsICB9ID0gcHJvcHM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsb2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb25DbGljaycgfHwga2V5ID09PSAnb25Nb3VzZUVudGVyJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGZ1bmN0aW9uYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdyZXBsYWNlJyB8fCBrZXkgPT09ICdzY3JvbGwnIHx8IGtleSA9PT0gJ3NoYWxsb3cnIHx8IGtleSA9PT0gJ3Bhc3NIcmVmJyB8fCBrZXkgPT09ICdwcmVmZXRjaCcgfHwga2V5ID09PSAnbGVnYWN5QmVoYXZpb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgaGFzV2FybmVkID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wICwgYXM6IGFzUHJvcCAsIGNoaWxkcmVuOiBjaGlsZHJlblByb3AgLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wICwgcGFzc0hyZWYgLCByZXBsYWNlICwgc2hhbGxvdyAsIHNjcm9sbCAsIGxvY2FsZSAsIG9uQ2xpY2sgLCBvbk1vdXNlRW50ZXIgIH0gPSBwcm9wcywgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXG4gICAgICAgIFwiaHJlZlwiLFxuICAgICAgICBcImFzXCIsXG4gICAgICAgIFwiY2hpbGRyZW5cIixcbiAgICAgICAgXCJwcmVmZXRjaFwiLFxuICAgICAgICBcInBhc3NIcmVmXCIsXG4gICAgICAgIFwicmVwbGFjZVwiLFxuICAgICAgICBcInNoYWxsb3dcIixcbiAgICAgICAgXCJzY3JvbGxcIixcbiAgICAgICAgXCJsb2NhbGVcIixcbiAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgIFwib25Nb3VzZUVudGVyXCJcbiAgICBdKTtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBjb25zdCBwID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX3JvdXRlcjEpLnVzZVJvdXRlcigpO1xuICAgIGNvbnN0IHsgaHJlZiAsIGFzICB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcm91dGVyKS5yZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWZQcm9wLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGFzOiBhc1Byb3AgPyAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaHJlZlByb3AsXG4gICAgICAgIGFzUHJvcFxuICAgIF0pO1xuICAgIGNvbnN0IHByZXZpb3VzSHJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihocmVmKTtcbiAgICBjb25zdCBwcmV2aW91c0FzID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGFzKTtcbiAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICBsZXQgY2hpbGQ7XG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFwib25DbGlja1wiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25DbGljayBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6ICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGUsIHJlc2V0VmlzaWJsZV0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgcm9vdE1hcmdpbjogJzIwMHB4J1xuICAgIH0pO1xuICAgIGNvbnN0IHNldFJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZUNhbGxiYWNrKChlbCk9PntcbiAgICAgICAgLy8gQmVmb3JlIHRoZSBsaW5rIGdldHRpbmcgb2JzZXJ2ZWQsIGNoZWNrIGlmIHZpc2libGUgc3RhdGUgbmVlZCB0byBiZSByZXNldFxuICAgICAgICBpZiAocHJldmlvdXNBcy5jdXJyZW50ICE9PSBhcyB8fCBwcmV2aW91c0hyZWYuY3VycmVudCAhPT0gaHJlZikge1xuICAgICAgICAgICAgcmVzZXRWaXNpYmxlKCk7XG4gICAgICAgICAgICBwcmV2aW91c0FzLmN1cnJlbnQgPSBhcztcbiAgICAgICAgICAgIHByZXZpb3VzSHJlZi5jdXJyZW50ID0gaHJlZjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWYoZWwpO1xuICAgICAgICBpZiAoY2hpbGRSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdmdW5jdGlvbicpIGNoaWxkUmVmKGVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBjaGlsZFJlZixcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVzZXRWaXNpYmxlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgY29uc3Qgc2hvdWxkUHJlZmV0Y2ggPSBpc1Zpc2libGUgJiYgcCAmJiAoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKTtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNQcmVmZXRjaGVkID0gcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXTtcbiAgICAgICAgaWYgKHNob3VsZFByZWZldGNoICYmICFpc1ByZWZldGNoZWQpIHtcbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGN1ckxvY2FsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcCxcbiAgICAgICAgcm91dGVyXG4gICAgXSk7XG4gICAgY29uc3QgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgcmVmOiBzZXRSZWYsXG4gICAgICAgIG9uQ2xpY2s6IChlKT0+e1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXI6IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICAgIGlmICghbGVnYWN5QmVoYXZpb3IgfHwgcGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkge1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSByb3V0ZXIgJiYgcm91dGVyLmlzTG9jYWxlRG9tYWluICYmICgwLCBfcm91dGVyKS5nZXREb21haW5Mb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5sb2NhbGVzLCByb3V0ZXIgJiYgcm91dGVyLmRvbWFpbkxvY2FsZXMpO1xuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBsb2NhbGVEb21haW4gfHwgKDAsIF9yb3V0ZXIpLmFkZEJhc2VQYXRoKCgwLCBfcm91dGVyKS5hZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzLCBjaGlsZFByb3BzKSwgY2hpbGRyZW4pO1xufSk7XG52YXIgX2RlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSB7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3JvdXRlciIsIl9yb3V0ZXIxIiwiX3VzZUludGVyc2VjdGlvbiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiaSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvdG90eXBlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwic291cmNlS2V5cyIsImtleXMiLCJwcmVmZXRjaGVkIiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiaXNMb2NhbFVSTCIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImN1ckxvY2FsZSIsImxvY2FsZSIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwiTGluayIsImZvcndhcmRSZWYiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsImxlZ2FjeUJlaGF2aW9yIiwiQm9vbGVhbiIsImVudiIsIl9fTkVYVF9ORVdfTElOS19CRUhBVklPUiIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjaGlsZHJlbiIsImhyZWZQcm9wIiwiYXNQcm9wIiwiY2hpbGRyZW5Qcm9wIiwicHJlZmV0Y2hQcm9wIiwicmVzdFByb3BzIiwiY3JlYXRlRWxlbWVudCIsInAiLCJ1c2VSb3V0ZXIiLCJ1c2VNZW1vIiwicmVzb2x2ZUhyZWYiLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwicHJldmlvdXNIcmVmIiwicHJldmlvdXNBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwiY2hpbGRSZWYiLCJyZWYiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsInNob3VsZFByZWZldGNoIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmlvcml0eSIsInR5cGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiYXNzaWduIiwiX2RlZmF1bHQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver !== \"undefined\";\nfunction useIntersection(param) {\n    var rootRef = param.rootRef, rootMargin = param.rootMargin, disabled = param.disabled;\n    _s();\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var unobserve = (0, _react).useRef();\n    var ref = _slicedToArray((0, _react).useState(false), 2), visible = ref[0], setVisible = ref[1];\n    var ref1 = _slicedToArray((0, _react).useState(rootRef ? rootRef.current : null), 2), root = ref1[0], setRoot = ref1[1];\n    var setRef = (0, _react).useCallback(function(el) {\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, function(isVisible) {\n                return isVisible && setVisible(isVisible);\n            }, {\n                root: root,\n                rootMargin: rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        root,\n        rootMargin,\n        visible\n    ]);\n    var resetVisible = (0, _react).useCallback(function() {\n        setVisible(false);\n    }, []);\n    (0, _react).useEffect(function() {\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n                };\n            }\n        }\n    }, [\n        visible\n    ]);\n    (0, _react).useEffect(function() {\n        if (rootRef) setRoot(rootRef.current);\n    }, [\n        rootRef\n    ]);\n    return [\n        setRef,\n        visible,\n        resetVisible\n    ];\n}\n_s(useIntersection, \"v899qx2Oxsy68lv6LR1+qv/1rnU=\");\nfunction observe(element, callback, options) {\n    var ref = createObserver(options), id = ref.id, observer = ref.observer, elements = ref.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            var index = idList.findIndex(function(obj) {\n                return obj.root === id.root && obj.margin === id.margin;\n            });\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n    var id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    var existing = idList.find(function(obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n    });\n    var instance;\n    if (existing) {\n        instance = observers.get(existing);\n    } else {\n        instance = observers.get(id);\n        idList.push(id);\n    }\n    if (instance) {\n        return instance;\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    });\n    return instance;\n}\nif (typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) {\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUUsSUFBSTtDQUNkLEVBQUMsQ0FBQztBQUNIRCx1QkFBdUIsR0FBR0UsZUFBZSxDQUFDO0FBQzFDLElBQUlDLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBTyxDQUFDO0FBQzdCLElBQUlDLG9CQUFvQixHQUFHRCxtQkFBTyxDQUFDLHlGQUF5QixDQUFDO0FBQzdELElBQU1FLHVCQUF1QixHQUFHLE9BQU9DLG9CQUFvQixLQUFLLFdBQVc7QUFDM0UsU0FBU0wsZUFBZSxDQUFDLEtBQW9DLEVBQUU7UUFBcENNLE9BQU8sR0FBVCxLQUFvQyxDQUFsQ0EsT0FBTyxFQUFHQyxVQUFVLEdBQXRCLEtBQW9DLENBQXhCQSxVQUFVLEVBQUdDLFFBQVEsR0FBakMsS0FBb0MsQ0FBWEEsUUFBUTs7SUFDdEQsSUFBTUMsVUFBVSxHQUFHRCxRQUFRLElBQUksQ0FBQ0osdUJBQXVCO0lBQ3ZELElBQU1NLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRVQsTUFBTSxDQUFDLENBQUNVLE1BQU0sRUFBRTtJQUN0QyxJQUE4QixHQUEyQixrQkFBM0IsQ0FBQyxDQUFDLEVBQUVWLE1BQU0sQ0FBQyxDQUFDVyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQWxEQyxPQUFPLEdBQWdCLEdBQTJCLEdBQTNDLEVBQUVDLFVBQVUsR0FBSSxHQUEyQixHQUEvQjtJQUMxQixJQUF3QixJQUFzRCxrQkFBdEQsQ0FBQyxDQUFDLEVBQUViLE1BQU0sQ0FBQyxDQUFDVyxRQUFRLENBQUNOLE9BQU8sR0FBR0EsT0FBTyxDQUFDUyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQXZFQyxJQUFJLEdBQWEsSUFBc0QsR0FBbkUsRUFBRUMsT0FBTyxHQUFJLElB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TWYsUUFBUSxHQUFHLElBQUlZLEdBQUcsRUFBRTtJQUMxQixJQUFNYixRQUFRLEdBQUcsSUFBSTlCLG9CQUFvQixDQUFDLFNBQUNpRCxPQUFPLEVBQUc7UUFDakRBLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLFNBQUNDLEtBQUssRUFBRztZQUNyQixJQUFNekIsUUFBUSxHQUFHSyxRQUFRLENBQUNnQixHQUFHLENBQUNJLEtBQUssQ0FBQ0MsTUFBTSxDQUFDO1lBQzNDLElBQU1qQyxTQUFTLEdBQUdnQyxLQUFLLENBQUNFLGNBQWMsSUFBSUYsS0FBSyxDQUFDRyxpQkFBaUIsR0FBRyxDQUFDO1lBQ3JFLElBQUk1QixRQUFRLElBQUlQLFNBQVMsRUFBRTtnQkFDdkJPLFFBQVEsQ0FBQ1AsU0FBUyxDQUFDLENBQUM7YUFDdkI7U0FDSixDQUFDLENBQUM7S0FDTixFQUFFUSxPQUFPLENBQUM7SUFDWFMsU0FBUyxDQUFDSixHQUFHLENBQUNILEVBQUUsRUFBRWlCLFFBQVEsR0FBRztRQUN6QmpCLEVBQUUsRUFBRkEsRUFBRTtRQUNGQyxRQUFRLEVBQVJBLFFBQVE7UUFDUkMsUUFBUSxFQUFSQSxRQUFRO0tBQ1gsQ0FBQyxDQUFDO0lBQ0gsT0FBT2UsUUFBUSxDQUFDO0NBQ25CO0FBRUQsSUFBSSxPQUFPckQsT0FBTyxDQUFDOEQsT0FBTyxLQUFLLFVBQVUsSUFBSyxPQUFPOUQsT0FBTyxDQUFDOEQsT0FBTyxLQUFLLFFBQVEsSUFBSTlELE9BQU8sQ0FBQzhELE9BQU8sS0FBSyxJQUFJLEVBQUc7SUFDOUdoRSxNQUFNLENBQUNpRSxNQUFNLENBQUMvRCxPQUFPLENBQUM4RCxPQUFPLEVBQUU5RCxPQUFPLENBQUMsQ0FBQztJQUN4Q2dFLE1BQU0sQ0FBQ2hFLE9BQU8sR0FBR0EsT0FBTyxDQUFDOEQsT0FBTyxDQUFDO0NBQ2xDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uID0gdXNlSW50ZXJzZWN0aW9uO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbih7IHJvb3RSZWYgLCByb290TWFyZ2luICwgZGlzYWJsZWQgIH0pIHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IHVub2JzZXJ2ZSA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcm9vdCwgc2V0Um9vdF0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShyb290UmVmID8gcm9vdFJlZi5jdXJyZW50IDogbnVsbCk7XG4gICAgY29uc3Qgc2V0UmVmID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50KCk7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm47XG4gICAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IG9ic2VydmUoZWwsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpXG4gICAgICAgICAgICAsIHtcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFZpc2libGUodHJ1ZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5jYW5jZWxJZGxlQ2FsbGJhY2soaWRsZUNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgdmlzaWJsZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAocm9vdFJlZikgc2V0Um9vdChyb290UmVmLmN1cnJlbnQpO1xuICAgIH0sIFtcbiAgICAgICAgcm9vdFJlZlxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgcmVzZXRWaXNpYmxlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkICwgb2JzZXJ2ZXIgLCBlbGVtZW50cyAgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlkTGlzdCA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0ge1xuICAgICAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJydcbiAgICB9O1xuICAgIGxldCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICApO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpO1xuICAgICAgICBpZExpc3QucHVzaChpZCk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpIHtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwiY3VycmVudCIsInJvb3QiLCJzZXRSb290Iiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJvYnNlcnZlIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlRWZmZWN0IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsImVsZW1lbnQiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJjcmVhdGVPYnNlcnZlciIsImlkIiwib2JzZXJ2ZXIiLCJlbGVtZW50cyIsInNldCIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0Iiwib2JzZXJ2ZXJzIiwiaW5kZXgiLCJpZExpc3QiLCJmaW5kSW5kZXgiLCJvYmoiLCJtYXJnaW4iLCJzcGxpY2UiLCJNYXAiLCJleGlzdGluZyIsImZpbmQiLCJpbnN0YW5jZSIsImdldCIsInB1c2giLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwidGFyZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsImRlZmF1bHQiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "./pages/Huolto/lisaaHuolto.js":
/*!*************************************!*\
  !*** ./pages/Huolto/lisaaHuolto.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Huolto; }\n/* harmony export */ });\n/* harmony import */ var C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\");\n/* harmony import */ var C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../styles/Formi.module.css */ \"./styles/Formi.module.css\");\n/* harmony import */ var _styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_Nav__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/Nav */ \"./components/Nav.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\n\n\n\n\n\nvar _s = $RefreshSig$();\n//import { GetServerSideProps } from 'next'\nfunction Huolto() {\n    _s();\n    console.log(\"Now in lisaaHuolto.js file\");\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({}), formData = ref[0], setFormData = ref[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), on = ref1[0], setOn = ref1[1];\n    var huoltoData = {\n        \"kohde\": formData.kohde,\n        \"huolto\": formData.huolto,\n        \"km\": parseInt(formData.km),\n        \"info\": formData.info\n    };\n    var saveHuolto = function() {\n        var _ref = _asyncToGenerator(C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(huolto) {\n            var response;\n            return C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        _ctx.next = 2;\n                        return fetch(\"../api/PostHuolto\", {\n                            method: \"POST\",\n                            body: JSON.stringify(huolto)\n                        });\n                    case 2:\n                        response = _ctx.sent;\n                        if (response.ok) {\n                            _ctx.next = 5;\n                            break;\n                        }\n                        throw new Error(response.statusText);\n                    case 5:\n                        _ctx.next = 7;\n                        return response.json();\n                    case 7:\n                        return _ctx.abrupt(\"return\", _ctx.sent);\n                    case 8:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee);\n        }));\n        return function saveHuolto(huolto) {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    var handleInputChange = function(event) {\n        console.log(event.target.name);\n        setFormData(function(preFormData) {\n            return _objectSpread({}, preFormData, _defineProperty({}, event.target.name, event.target.value));\n        });\n    };\n    console.log(\"formdata: \", formData);\n    var submitData = function() {\n        var _ref = _asyncToGenerator(C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(event) {\n            return C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        event.preventDefault;\n                        console.log(\"submitData: \", huoltoData);\n                        _ctx.next = 4;\n                        return saveHuolto(huoltoData);\n                    case 4:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee);\n        }));\n        return function submitData(event) {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    var readData = function() {\n        var _ref = _asyncToGenerator(C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n            var res;\n            return C_Users_JouniRiimala_Documents_repo_Rekisteri_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        _ctx.next = 2;\n                        return fetch(\"./api/Read\", {\n                            method: \"GET\"\n                        });\n                    case 2:\n                        res = _ctx.sent;\n                        return _ctx.abrupt(\"return\", {\n                            props: {\n                                res: res\n                            }\n                        });\n                    case 4:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee);\n        }));\n        return function readData() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    var show = function() {\n        return setOn(true);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_Nav__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                lineNumber: 65,\n                columnNumber: 5\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                className: (_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default().form),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"form\", {\n                    onSubmit: submitData,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"input\", {\n                            className: (_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default().input),\n                            type: \"text\",\n                            name: \"kohde\",\n                            placeholder: \"Kohde\",\n                            onChange: handleInputChange,\n                            value: formData.kohde\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                            lineNumber: 68,\n                            columnNumber: 9\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"input\", {\n                            className: (_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default().input),\n                            type: \"text\",\n                            name: \"huolto\",\n                            placeholder: \"Huolto\",\n                            onChange: handleInputChange,\n                            value: formData.huolto\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                            lineNumber: 77,\n                            columnNumber: 9\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"input\", {\n                            className: (_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default().input),\n                            type: \"number\",\n                            name: \"km\",\n                            placeholder: \"km\",\n                            onChange: handleInputChange,\n                            value: formData.km\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                            lineNumber: 86,\n                            columnNumber: 9\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"textarea\", {\n                            className: (_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default().input),\n                            name: \"info\",\n                            placeholder: \"Lis\\xe4info\",\n                            onChange: handleInputChange,\n                            value: formData.info\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                            lineNumber: 95,\n                            columnNumber: 9\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"button\", {\n                            className: (_styles_Formi_module_css__WEBPACK_IMPORTED_MODULE_4___default().button),\n                            children: \"Talleta\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                            lineNumber: 102,\n                            columnNumber: 9\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                    lineNumber: 67,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n                lineNumber: 66,\n                columnNumber: 5\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\JouniRiimala\\\\Documents\\\\repo\\\\Rekisteri\\\\pages\\\\Huolto\\\\lisaaHuolto.js\",\n        lineNumber: 64,\n        columnNumber: 5\n    }, this);\n};\n_s(Huolto, \"XRka4L4lQYXfWG+MWwYAOTQKgm4=\");\n_c = Huolto;\nvar _c;\n$RefreshReg$(_c, \"Huolto\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNGO0dBcEd1QkUsTUFBTTtBQUFOQSxLQUFBQSxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL0h1b2x0by9saXNhYUh1b2x0by5qcz8yN2IwIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQge3VzZVN0YXRlfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IGZvcm1pU3R5bGUgZnJvbSAnLi4vLi4vc3R5bGVzL0Zvcm1pLm1vZHVsZS5jc3MnXHJcbmltcG9ydCBOYXYgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvTmF2XCJcclxuLy9pbXBvcnQgeyBHZXRTZXJ2ZXJTaWRlUHJvcHMgfSBmcm9tICduZXh0J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSHVvbHRvKCkge1xyXG4gICAgY29uc29sZS5sb2coXCJOb3cgaW4gbGlzYWFIdW9sdG8uanMgZmlsZVwiKVxyXG4gICAgY29uc3QgW2Zvcm1EYXRhLCBzZXRGb3JtRGF0YV0gPSB1c2VTdGF0ZSh7fSlcclxuICAgIGNvbnN0IFtvbiwgc2V0T25dID0gdXNlU3RhdGUoZmFsc2UpXHJcblxyXG4gICAgY29uc3QgaHVvbHRvRGF0YSA9IHtcclxuICAgICAgICBcImtvaGRlXCI6IGZvcm1EYXRhLmtvaGRlLFxyXG4gICAgICAgIFwiaHVvbHRvXCI6IGZvcm1EYXRhLmh1b2x0byxcclxuICAgICAgICBcImttXCI6IHBhcnNlSW50KGZvcm1EYXRhLmttKSxcclxuICAgICAgICBcImluZm9cIjogZm9ybURhdGEuaW5mbywgICAgICAgICAgICBcclxuICAgIH1cclxuICAgICAgXHJcbiAgICBjb25zdCBzYXZlSHVvbHRvID0gYXN5bmMoaHVvbHRvKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnLi4vYXBpL1Bvc3RIdW9sdG8nLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDonUE9TVCcsXHJcbiAgICAgICAgICAgIGJvZHk6SlNPTi5zdHJpbmdpZnkoaHVvbHRvKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC5uYW1lKVxyXG4gICAgICAgIHNldEZvcm1EYXRhKHByZUZvcm1EYXRhID0+IHtcclxuICAgICAgICAgICAgcmV0dXJue1xyXG4gICAgICAgICAgICAgICAgLi4ucHJlRm9ybURhdGEsXHJcbiAgICAgICAgICAgICAgICBbZXZlbnQudGFyZ2V0Lm5hbWVdOiBldmVudC50YXJnZXQudmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9IFxyXG5cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcImZvcm1kYXRhOiBcIiwgZm9ybURhdGEpXHJcblxyXG4gICAgY29uc3Qgc3VibWl0RGF0YSA9IGFzeW5jIChldmVudCkgPT4geyBcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdDsgICAgICAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdWJtaXREYXRhOiBcIiwgaHVvbHRvRGF0YSk7ICAgIFxyXG4gICAgICAgIGF3YWl0IHNhdmVIdW9sdG8oaHVvbHRvRGF0YSkgICAgICAgICAgXHJcbiAgICB9ICAgIFxyXG5cclxuICAgIGNvbnN0IHJlYWREYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcuL2FwaS9SZWFkJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6J0dFVCdcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm57XHJcbiAgICAgICAgICAgIHByb3BzOntyZXN9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgY29uc3Qgc2hvdyA9ICgpID0+IHNldE9uKHRydWUpXHJcbiAgICByZXR1cm4gKFxyXG4gICAgPGRpdj5cclxuICAgIDxOYXYgLz5cclxuICAgIDxkaXYgY2xhc3NOYW1lID0ge2Zvcm1pU3R5bGUuZm9ybX0+XHJcbiAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3N1Ym1pdERhdGF9PlxyXG4gICAgICAgIDxpbnB1dCBcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0ge2Zvcm1pU3R5bGUuaW5wdXR9XHJcbiAgICAgICAgICAgIHR5cGUgPSBcInRleHRcIlxyXG4gICAgICAgICAgICBuYW1lID0gXCJrb2hkZVwiXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gXCJLb2hkZVwiXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX1cclxuICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLmtvaGRlfVxyXG4gICAgICAgIC8+XHJcblxyXG4gICAgICAgIDxpbnB1dCBcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0ge2Zvcm1pU3R5bGUuaW5wdXR9XHJcbiAgICAgICAgICAgIHR5cGUgPSBcInRleHRcIlxyXG4gICAgICAgICAgICBuYW1lID0gXCJodW9sdG9cIlxyXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IFwiSHVvbHRvXCJcclxuICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfVxyXG4gICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEuaHVvbHRvfVxyXG4gICAgICAgIC8+XHJcblxyXG4gICAgICAgIDxpbnB1dCBcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0ge2Zvcm1pU3R5bGUuaW5wdXR9XHJcbiAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiXHJcbiAgICAgICAgICAgIG5hbWUgPSBcImttXCJcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBcImttXCJcclxuICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSAgICAgICAgXHJcbiAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YS5rbX1cclxuICAgICAgICAvPlxyXG5cclxuICAgICAgICA8dGV4dGFyZWEgXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHtmb3JtaVN0eWxlLmlucHV0fSAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBuYW1lID0gXCJpbmZvXCJcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBcIkxpc8OkaW5mb1wiXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gICAgICAgIFxyXG4gICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEuaW5mb31cclxuICAgICAgICAvPlxyXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lID0ge2Zvcm1pU3R5bGUuYnV0dG9ufT5UYWxsZXRhPC9idXR0b24+XHJcbiAgICAgICAgPC9mb3JtPlxyXG4gICAgPC9kaXY+ICAgXHJcbjwvZGl2PlxyXG4gIClcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiZm9ybWlTdHlsZSIsIk5hdiIsIkh1b2x0byIsImNvbnNvbGUiLCJsb2ciLCJmb3JtRGF0YSIsInNldEZvcm1EYXRhIiwib24iLCJzZXRPbiIsImh1b2x0b0RhdGEiLCJrb2hkZSIsImh1b2x0byIsInBhcnNlSW50Iiwia20iLCJpbmZvIiwic2F2ZUh1b2x0byIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwianNvbiIsImhhbmRsZUlucHV0Q2hhbmdlIiwiZXZlbnQiLCJ0YXJnZXQiLCJuYW1lIiwicHJlRm9ybURhdGEiLCJ2YWx1ZSIsInN1Ym1pdERhdGEiLCJwcmV2ZW50RGVmYXVsdCIsInJlYWREYXRhIiwicmVzIiwicHJvcHMiLCJzaG93IiwiZGl2IiwiY2xhc3NOYW1lIiwiZm9ybSIsIm9uU3VibWl0IiwiaW5wdXQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbkNoYW5nZSIsInRleHRhcmVhIiwiYnV0dG9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/Huolto/lisaaHuolto.js\n");

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n// ATTENTION\n\nvar REACT_ELEMENT_TYPE =  Symbol.for('react.element');\nvar REACT_PORTAL_TYPE =  Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE =  Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE =  Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE =  Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE =  Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE =  Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE =  Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE =  Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE =  Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE =  Symbol.for('react.memo');\nvar REACT_LAZY_TYPE =  Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE =  Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL =  Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7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O0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzE3ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbi8vIEFUVEVOVElPTlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9ICBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n");

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CJouniRiimala%5CDocuments%5Crepo%5CRekisteri%5Cpages%5CHuolto%5ClisaaHuolto.js&page=%2FHuolto%2FlisaaHuolto!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);